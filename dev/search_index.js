var documenterSearchIndex = {"docs":
[{"location":"intro/running/","page":"-","title":"-","text":"You have a data sequence Data, for our initial purposes it is a Vector [1, 2, 3, 4, 5]. The span of each subsequence is 3. The function to be applied over subsequences of Data is sum.","category":"page"},{"location":"intro/running/","page":"-","title":"-","text":"using RollingFunctions\n\n_Data_ = [1, 2, 3, 4, 5]\n_Func_ = sum\n_Span_ = 3\n\nresult = running(_Func_, _Data_, _Span_)\njulia> result\n3-element Vector{Int64}:\n  6\n  9\n 12\n\n#=\nThe first  windowed value is the _Func_ (`sum`) of the first  _Span_ (`3`) values in _Data_.\nThe second windowed value is the _Func_ (`sum`) of the second _Span_ (`3`) values in _Data_.\nThe third  windowed value is the _Func_ (`sum`) of the third  _Span_ (`3`) values in _Data_.\n\nThere can be no fourth value as the third value used the fins entries in _Data_.\n=#\n\njulia> sum(_Data_[1:3]), sum(_Data_[2:4]), sum(_Data_[3:5])\n(6, 9, 12)\nIf the span of each subsequence increases to 4..\n\n_Span_ = 4\nresult = running(_Func_, _Data_, _Span_);\n\nresult\n2-element Vector{Int64}:\n 10\n 14","category":"page"},{"location":"intro/running/","page":"-","title":"-","text":"Generally, with data that has r rows using a window_span of w results in r - w + 1 rows of values.","category":"page"},{"location":"references/","page":"References","title":"References","text":"references","category":"page"},{"location":"references/","page":"References","title":"References","text":"abcd","category":"page"},{"location":"tech/windowsorts/","page":"window sorts","title":"window sorts","text":"There are two distinct sorts of windows that are taken over data: rolling and tiled.  Rolling windows advance step-by-step over the data, each step advances the indices spanned by 1 (usually).  Tiled windows advance in larger steps (a multistep) over the data, each multistep advances the indices spanned by a preset amount, the length of the multistep.  ","category":"page"},{"location":"tech/windowsorts/","page":"window sorts","title":"window sorts","text":"With tiled windows, the tiling (the span that describes the indices covered by each tile) and the multistep increment are usually the the same. An example is summarizing a week of daily data and then moving to the following week.  To use a multistep increment that is shorter than the tiling is permitted, as is the use of an increment that is longer than the the tiling ‚Äì although that is rarely needed.  An example might be summarizing a week of daily data and the skipping over the next week, moving to the second week following for some analytic purpose.","category":"page"},{"location":"api/run/#*run*","page":"run","title":"run","text":"","category":"section"},{"location":"api/run/","page":"run","title":"run","text":"abcd","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"You have a data sequence _Data_, it is a Vector [1, 2, 3, 4, 5].\nThe span of each subsequence is 3.\nThe function to be applied over subsequences of _Data_ is `sum`.","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"using RollingFunctions\n\n_Data_ = [1, 2, 3, 4, 5]\n_Func_ = sum\n_Span_ = 3\n\nresult = rolling(_Func_, _Data_, _Span_)\njulia> result\n3-element Vector{Int64}:\n  6\n  9\n 12\n\n#=\nThe first  windowed value is the _Func_ (`sum`) of the first  _Span_ (`3`) values in _Data_.\nThe second windowed value is the _Func_ (`sum`) of the second _Span_ (`3`) values in _Data_.\nThe third  windowed value is the _Func_ (`sum`) of the third  _Span_ (`3`) values in _Data_.\n\nThere can be no fourth value as the third value used the fins entries in _Data_.\n=#\n\njulia> sum(_Data_[1:3]), sum(_Data_[2:4]), sum(_Data_[3:5])\n(6, 9, 12)\nIf the span of each subsequence increases to 4..\n\n_Span_ = 4\nresult = rolling(_Func_, _Data_, _Span_);\n\nresult\n2-element Vector{Int64}:\n 10\n 14","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"Data with r rows using a window_span of w results in r - w + 1 values.","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"to obtain r values, use padding or tapering","category":"page"},{"location":"tech/arity/","page":"function arity","title":"function arity","text":"Function Arities","category":"page"},{"location":"tech/arity/","page":"function arity","title":"function arity","text":"abcd","category":"page"},{"location":"intro/matrix_rolling/","page":"Rolling over Data Matricies (basics)","title":"Rolling over Data Matricies (basics)","text":"You have n data vectors of equal length (rowcount ùìá)\n`_Data_‚ÇÅ .. _Data_·µ¢ ..  _Data_‚Çô`  collected as an ùìá x ùìÉ matrix ‚Ñ≥\nyou want to apply the same function (sum) \nto subsequences of each column using a window_span of 3","category":"page"},{"location":"intro/matrix_rolling/","page":"Rolling over Data Matricies (basics)","title":"Rolling over Data Matricies (basics)","text":"using RollingFunctions\n\n_Data_‚ÇÅ = [1, 2, 3, 4, 5]\n_Data_‚ÇÇ = [5, 4, 3, 2, 1]\n_Data_‚ÇÉ = [1, 2, 3, 2, 1]\n\n‚Ñ≥ = hcat(_Data_‚ÇÅ, _Data_‚ÇÇ, _Data_‚ÇÉ)\n#=\n5√ó3 Matrix{Int64}:\n 1  5  1\n 2  4  2\n 3  3  3\n 4  2  2\n 5  1  1\n=#\n\n_Func_ = sum\n_Span_ = 3\n\nresult = rolling(_Func_, ‚Ñ≥, _Span_)\n#=\n3√ó3 Matrix{Int64}:\n  6  12  6\n  9   9  7\n 12   6  6\n=#\n","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"You may pad the result with the padding value of your choice","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"padding is a keyword argument","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"if you assign e.g. padding = missing, the result will be padded\nyou may pad using any defined value and all types except Nothing\nexample pads (missing, 0, nothing, NaN, '‚àÖ', AbstractString)","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"using RollingFunctions\n\n_Data_‚ÇÅ = [1, 2, 3, 4, 5]\n_Data_‚ÇÇ = [5, 4, 3, 2, 1]\n\n_Func_ = cov\n_Span_ = 3\n\nresult = rolling(_Func_, _Data_‚ÇÅ, _Data_‚ÇÇ, _Span_; padding = zero(eltype(‚Ñ≥)))\n#=\n5 element Vector {Float64}:\n  0.0\n  0.0\n -1.0\n -1.0\n -1.0\n=#","category":"page"},{"location":"intro/multicolumn_padding/#Give-me-the-real-values-first,-pad-to-the-end.","page":"Rolling over multicolumn data (padding)","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"result = rolling(_Func_, _Data_‚ÇÅ, _Data_‚ÇÇ, _Span_; padding = missing, padlast=true)\n#=\n5 element Vector {Float64}:\n -1.0\n -1.0\n -1.0\n  missing\n  missing\n=#","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"technical aside: this is not the same as reverse(rolling(Func, Data‚ÇÅ, Data‚ÇÇ, Span; padding = missing).","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"","category":"page"},{"location":"use/runoverdata/#This-package-makes-it-easy-to-summarize-windowed-data.","page":"Running over windowed data","title":"This package makes it easy to summarize windowed data.","text":"","category":"section"},{"location":"use/runoverdata/#A-function-is-applied-to-successive-data-subsequences.","page":"Running over windowed data","title":"A function is applied to successive data subsequences.","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"You give a summarizing function Func, the data Data, and a window span Span.  ","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"The result ‚Ñõ is of length ‚Ñõ·¥∫, ‚Ñõ·¥∫ = length(Data) - Span + 1`.","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"the result omits ‚Ñõ·¥º, ‚Ñõ·¥º = _Span_ - 1 indices into Data.","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"","category":"page"},{"location":"use/runoverdata/#*ways-to-get-as-many-results-as-there-are-data-values*","page":"Running over windowed data","title":"ways to get as many results as there are data values","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"","category":"page"},{"location":"use/runoverdata/#Use-a-vector-of-padding-values-with-length-‚Ñõ·¥º","page":"Running over windowed data","title":"Use a vector of padding values with length ‚Ñõ·¥º","text":"","category":"section"},{"location":"use/runoverdata/#specify-a-padding-vector-(default-is-at-the-start)","page":"Running over windowed data","title":"specify a padding vector (default is at the start)","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"here is the way to do that\nrunning(_Func_, _Data_, _Span_; padding = [<values>])\nrunning(function, data, window_span; padding = [<values>])","category":"page"},{"location":"use/runoverdata/#specify-the-padding-vector-to-be-at-the-end","page":"Running over windowed data","title":"specify the padding vector to be at the end","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"here is the way to do that\nrunning(_Func_, _Data_, _Span_; padding = [<values>], padlast = true)\nrunning(function, data, window_span; padding = [<values>], padlast = true)","category":"page"},{"location":"use/runoverdata/#Use-an-empty-vector","page":"Running over windowed data","title":"Use an empty vector","text":"","category":"section"},{"location":"use/runoverdata/#this-fills-the-‚Ñõ·¥º-indices-by-trimming","page":"Running over windowed data","title":"this fills the ‚Ñõ·¥º indices by trimming","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"here is the way to do that\nrunning(_Func_, _Data_, _Span_; padding = eltype(_Data_)[])\nrunning(function, data, window_span; padding = eltype(_Data_)[])\ntrimming evaluates the window function over available data\ntrimmed window spans are less than the specified window_span","category":"page"},{"location":"use/runoverdata/#Use-a-vector-of-ùìÉ-padding-values","page":"Running over windowed data","title":"Use a vector of ùìÉ padding values","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"where 1 <= ùìÉ < ‚Ñõ·¥º.","category":"page"},{"location":"use/runoverdata/#this-both-pads-and-trims-to-assign-the-initial-indices","page":"Running over windowed data","title":"this both pads and trims to assign the initial indices","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"the first ùìÉ indices of the result will match this vector\nthe next ‚Ñõ·¥º - ùìÉ indices of the result will be trimmed\nthe remaining indices get the rolled results.","category":"page"},{"location":"thanks/","page":"Thanks","title":"Thanks","text":"There have been many who contributed.  These few have done more than most, some without trying. I am grateful.","category":"page"},{"location":"thanks/","page":"Thanks","title":"Thanks","text":"name at\nEliot Saba @staticfloat\nBogumi≈Ç Kami≈Ñski @bkamins\nKevin Patel @kevindirect","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"Data Data‚Çó‚Çë‚Çô Span Span‚Çó‚Çë‚Çô  ùíØ ùíØ‚Çó‚Çë‚Çô  ùí´ ùí´‚Çó‚Çë‚Çô  ùí™ ùí™‚Å∫ ùí™‚Åª","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"Data Data‚Çô Span Span‚Çô  ùíØ ùíØ‚Çô  ùí´ ùí´‚Çô  ùí™ ùí™‚Å∫ ùí™‚Åª ‚Å∫ùí™‚Çô ‚Åªùí™‚Çô","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"We accept a data sequence DataùíÆ of type Vector{T} and of length DataùíÆ‚Çô (DataùíÆ[begin:end], length(DataùíÆ) == DataùíÆ‚Çô). We are given a window specification that includes its length, the span of any tiling, and more.","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"Given a data seqeunce of N elements and a window that spans W elements (W <= N),     ccompletewindows, rremainingindices = fldmod(N, W)     if iszero(remainingelements) the data sequence is covered exactly with ccompletewindows     otherwise, the data sequence is nearly fully covered with ccompletewindows, leaving rremaining_indices","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"N = c_complete_windows * W + r_remaining_indices\n0 = c_complete_windows * W + r_remaining_indices - N\nc_complete_windows * W = N - r_remaining_indices\nc_complete_windows = div((N - r_remaining_indices), W)\nW = div((N - r_remaining_indices), c_complete_windows)\nr_remaining_indices = N - c_complete_windows * W","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"The preceeding assumes that the window always advances by 1 index. Use A as the whole number of indices (1 <= A <= N-1-W) that window always advances. With A = N-1-W, there is exactly one advance, from index 1 to index 1+N-1-W = N-W    the repositioned window now starts at index N-W and spans W indices, N-W+W == N    and the window has nowhere more to traverse.","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"What value of A allows exactly 2 advances?     A1 = N-1-W, if iseven(A1) A2 = div(A1,2)     or, if isodd(N-W), A2 = div(N-W-1, 2)","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"","category":"page"},{"location":"use/rolloverdata/#This-package-makes-it-easy-to-summarize-windowed-data.","page":"Rolling over windowed data","title":"This package makes it easy to summarize windowed data.","text":"","category":"section"},{"location":"use/rolloverdata/#A-function-is-applied-to-successive-data-subsequences.","page":"Rolling over windowed data","title":"A function is applied to successive data subsequences.","text":"","category":"section"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"You give a summarizing function Func, the data Data, and a window span Span.  ","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"The result ‚Ñõ is of length ‚Ñõ·¥∫, ‚Ñõ·¥∫ = length(Data) - Span + 1`.","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"the result omits ‚Ñõ·¥º, ‚Ñõ·¥º = _Span_ - 1 indices into Data.\nhere is the way to do that\nrolling(_Func_, _Data_, _Span_)\nrolling(function, data, window_span)","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"","category":"page"},{"location":"use/rolloverdata/#*ways-to-get-as-many-results-as-there-are-data-values*","page":"Rolling over windowed data","title":"ways to get as many results as there are data values","text":"","category":"section"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"","category":"page"},{"location":"use/rolloverdata/#Use-a-single,-shared-padding-value","page":"Rolling over windowed data","title":"Use a single, shared padding value","text":"","category":"section"},{"location":"use/rolloverdata/#specify-a-padding-value-(default-position-is-at-the-start)","page":"Rolling over windowed data","title":"specify a padding value (default position is at the start)","text":"","category":"section"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"here is the way to do that\nrolling(_Func_, _Data_, _Span_; padding = <value>)\nrolling(function, data, window_span; padding = missing)\nthis will fill the initial result values with the padding value\npads these values (result[1], .., result[pad_nindices])","category":"page"},{"location":"use/rolloverdata/#specify-padding-to-be-at-the-end-of-the-result","page":"Rolling over windowed data","title":"specify padding to be at the end of the result","text":"","category":"section"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"here is the way to do that\nrolling(_Func_, _Data_, _Span_; padding = <value>, padlast = true)\nrolling(function, data, window_span; padding = missing, padlast = true)\nthis will fill the final result values with the padding value\npads these values (result[n-pad_nindices+1], .., result[n])","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"You may pad the result with the padding value of your choice","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"padding is a keyword argument","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"if you assign e.g. padding = missing, the result will be padded\nyou may pad using any defined value and all types except Nothing\nexample pads (missing, 0, nothing, NaN, '‚àÖ', AbstractString)","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"using RollingFunctions\n\n_Data_‚ÇÅ = [1, 2, 3, 4, 5]\n_Data_‚ÇÇ = [5, 4, 3, 2, 1]\n_Data_‚ÇÉ = [1, 2, 3, 2, 1]\n\n‚Ñ≥ = hcat(_Data_‚ÇÅ, _Data_‚ÇÇ, _Data_‚ÇÉ)\n#=\n5√ó3 Matrix{Int64}:\n 1  5  1\n 2  4  2\n 3  3  3\n 4  2  2\n 5  1  1\n=#\n\n_Func_ = sum\n_Span_ = 3\n\nresult = rolling(_Func_, ‚Ñ≥, _Span_; padding=missing)\n#=\n5√ó3 Matrix{Union{Missing,Int64}}:\nmissing missing missing\nmissing missing missing\n  6  12  6\n  9   9  7\n 12   6  6\n=#","category":"page"},{"location":"intro/matrix_padding/#Give-me-the-real-values-first,-pad-to-the-end.","page":"Rolling over Data Matrices (padding)","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"result = rolling(_Func_, ‚Ñ≥, _Span_; padding = missing, padlast=true)\n#=\n5√ó3 Matrix{Union{Missing,Int64}}:\n  6  12  6\n  9   9  7\n 12   6  6\n   missing    missing   missing\n   missing    missing   missing\n=#","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"technical aside: this is not the same as reverse(rolling(ùíÆ, Data, Span; padding = missing).","category":"page"},{"location":"intro/multicolumn_rolling/","page":"Rolling over multicolumn data (basics)","title":"Rolling over multicolumn data (basics)","text":"You have n data vectors of equal length (rowcount ùìá)\n`_Data_‚ÇÅ .. _Data_·µ¢ ..  _Data_‚Çô`\nyou want to apply a function of n arguments\nhere, n = 2 and the function is `StatsBase.cor`\nto subsequences over the vectors using a window_span of 3","category":"page"},{"location":"intro/multicolumn_rolling/","page":"Rolling over multicolumn data (basics)","title":"Rolling over multicolumn data (basics)","text":"using RollingFunctions\n\n_Data_‚ÇÅ = [1, 2, 3, 4, 5]\n_Data_‚ÇÇ = [5, 4, 3, 2, 1]\n\n_Func_ = cor\n_Span_ = 3\n\nresult = rolling(_Func_, _Data_‚ÇÅ, _Data_‚ÇÇ, _Span_)\n#=\n3-element Vector{Float64}:\n  -1.0\n  -1.0\n  -1.0\n=#","category":"page"},{"location":"tech/windows/#Window-Representations","page":"window structs","title":"Window Representations","text":"","category":"section"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"Multiple structs are used internally to model the constructive details and applicative rules for a Window over client data. All inherit from AbstractWindowing","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"abstract type AbstractWindow end\n\n@kwdef mutable struct BasicWindow <: AbstractWindow\n    const length::Int              # span of contiguous elements\n    \n    direct::Bool=true              # process from low indices to high\n\n    const onlywhole::Bool=true     # prohibit partial window\n    const drop_first::Bool=true    # omit results at start¬π, if needed¬≤\n    const drop_final::Bool=false   # omit results at finish¬π, if needed¬≤\nend","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"@kwdef mutable struct Window{T} <: AbstractWindow\n    const length::Int              # span of contiguous elements\n    \n    offset_first::Int=0            # start  at index offset_first + 1\n    offset_final::Int=0            # finish at index length - offset_final + 1\n\n    pad_first::Int=0               # pad with this many paddings at start\n    pad_final::Int=0               # pad with this many padding at end\n    const padding::T=nothing       # use this as the value with which to pad\n\n    const direct::Bool=true        # process from low indices to high\n\n    const onlywhole::Bool=true     # prohibit partial windows\n    const drop_first::Bool=true    # omit results at start¬π, if needed¬≤\n    const drop_final::Bool=false   # omit results at finish¬π, if needed¬≤\n\n    const trim_first::Bool=false   # use partial windowing over first elements, if needed\n    const trim_final::Bool=false   # use partial windowing over final elements, if needed\n    \n    const fill_first::Bool=true    # a simpler, often faster alternative to trim\n    const fill_final::Bool=false   # a simpler, often faster alternative to trim\nend\n\n# is indexing to be offset\nnotoffset(w::Window) = iszero(w.offset_first) && iszero(w.offset_final)\nisoffset(w::Window) = !notoffset(w)\n# >> specifying both a leading offset and a trailing offset is supported\n\n# is there to be padding\nnotpadded(w::Window) = iszero(w.pad_first) && iszero(w.pad_final)\nispadded(w::Window) = !notpadded(w)\n# >> it is an error to specify both a leading padding and a trailing padding\n\n# is the information processed in direct (lower index to higher index) order\nisdirect(w::Window) = w.direct\n\n# are only complete window spans to be allowed\nonlywhole(w::Window) = w.onlywhole\nallowpartial(w::Window) = !onlywhole(w)\n\n# is dropping incomplete results expected\nisdropping(w::Window) = (w.drop_first ‚äª w.drop_final)\nnotdropping(w::Window) = !isdropping(w)\n# >> it is an error to select both `drop_first` and `drop_final`\n  \n# is trimmed windowing to be allowed\nmaytrim(w::Window) = allowspartials(w) && (w.trim_first ‚äª w.trim_last)\n# >> it is an error to select both `trim_first` and `trim_final`\n# >> it is an error to select either `trim` and select any `fill`\n\n# is filled windowing to be allowed\nmayfill(w::Window) = allowspartials(w) && (w.fill_first ‚äª w.fill_last)\n# >> it is an error to select both `fill_first` and `fill_final`\n# >> it is an error to select either `fill` and select any `trim`","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"@kwdef mutable struct WeightedWindow{Pad,F,T} <: AbstractWindow\n    window::Window{Pad}          # struct annotated above\n    weightfun::F=nothing         # a function that yields the weights\n    weighting::Vector{T}         # the weights collected\nend\n\n# the weight function is optional\n# if you specify a weight function, the `weighting` will be autogenerated\n# >> weightings are checked to ensure they sum to 1\n\n----\n","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"¬π \"at start\"  is from the lowest  indices where `direct == true`\n              is from the highest indices where `direct == false`\n\n  \"at finish\" is from the highest indices where `direct == true`\n              is from the lowest  indices where `direct == false`\n\n¬≤ \"if needed\" is true if and only if `onlywhole == true` and\n              `!iszero(rem(data_length, window_length))`","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"```","category":"page"},{"location":"intro/stepping/","page":"-","title":"-","text":"(Stepping through Windowed Data)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"You have a data sequence Data, for now it is a Vector [1, 2, 3, 4, 5].\nThe window span Span of each subsequence is 3.\nThe function Func to be applied over subsequences of Data is sum.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using RollingFunctions\n\n_Data_ = [1, 2, 3, 4, 5]\n_Func_ = sum\n_Span_ = 3\n\nrolled = rolling(_Func_, _Data_, _Span_)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"julia> rolled\n3-element Vector{Int64}:\n  6\n  9\n 12\n\n#=\nThe first  windowed value is the _Func_ (`sum`) of the first  _Span_ (`3`) values in _Data_.\nThe second windowed value is the _Func_ (`sum`) of the second _Span_ (`3`) values in _Data_.\nThe third  windowed value is the _Func_ (`sum`) of the third  _Span_ (`3`) values in _Data_.\n\nThere can be no fourth value as the third value used the fins entries in _Data_.\n=#\n\njulia> sum(_Data_[1:3]), sum(_Data_[2:4]), sum(_Data_[3:5])\n(6, 9, 12)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"If the span of each subsequence increases to 4..","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"_Span_ = 4\nrolled = rolling(_Data_, _Span_, ùíÆ);\n\nrolled\n2-element Vector{Int64}:\n 10\n 14","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Generally, with data that has r rows using a window_span of w results in r - w + 1 rows of values.","category":"page"},{"location":"overview/#To-get-back-a-result-with-the-same-number-of-rows-as-your-data","page":"Overview","title":"To get back a result with the same number of rows as your data","text":"","category":"section"},{"location":"overview/#Welcome-to-the-wonderful-world-of-padding","page":"Overview","title":"Welcome to the wonderful world of padding","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"You may pad the result with the padding value of your choice","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"padding is a keyword argument\nif you assign e.g. padding = missing, the result will be padded","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"missing, 0.0 are commonly used, however all values save Nothing are permitted    ‚Äì using nothing as the padding is allowed; using the type Nothing is not","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using RollingFunctions\n\n_Data_ = [1, 2, 3, 4, 5]\n_Func_ = sum\n_Span_ = 3\n\nrolled = rolling(_Func_, _Data_, _Span_; padding = missing);\n\njulia> rolled\n5-element Vector{Union{Missing, Int64}}:\n   missing\n   missing\n   missing\n 10\n 14\n \nrolled = rolling(_Data_, _Span_, ùíÆ; padding = zero(eltype(_Data_));\njulia> rolled\n5-element Vector{Int64}:\n  0\n  0\n  0\n 10\n 14\n ```\n\n### Give me the real values first, pad to the end.\n","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"rolled = rolling(Func, Data, Span; padding = zero(eltype(Data), padlast=true); julia> rolled 5-element Vector{Int64}:  10  14   0   0   0 ```","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"technical note: this is not the same as reverse(rolling(_Data_, _Span_, ùíÆ; padding = zero(eltype(_Data_)).","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"You may pad the result with the padding value of your choice","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"padding is a keyword argument","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"if you assign e.g. padding = missing, the result will be padded\nyou may pad using any defined value and all types except Nothing\nexample pads (missing, 0, nothing, NaN, '‚àÖ', AbstractString)","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"using RollingFunctions\n\n_Data_ = [1, 2, 3, 4, 5]\n_Func_ = sum\n_Span_ = 3\n\nresult = rolling(_Func_, _Data_, _Span_; padding = missing);\n#=\n5-element Vector{Union{Missing, Int64}}:\n   missing\n   missing\n  6\n  9\n 12\n=#\n \nresult = rolling(_Func_, _Data_, _Span_; padding = zero(eltype(_Data_));\n#=\n5-element Vector{Int64}:\n  0\n  0\n  6\n  9\n 12\n=#","category":"page"},{"location":"intro/padding/#Give-me-the-real-values-first,-pad-to-the-end.","page":"Rolling over Data (padding)","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"result = rolling(_Func_, _Data_, _Span_; padding = missing, padlast=true);\n#=\n5-element Vector{Union{Missing,Int64}}:\n  6\n  9\n 12\n  missing\n  missing\n=#","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"technical aside: this is not the same as reverse(rolling(Func, Data, Span; padding = zero(eltype(Data)).","category":"page"},{"location":"api/roll/#*roll*","page":"roll","title":"roll","text":"","category":"section"},{"location":"api/roll/","page":"roll","title":"roll","text":"abcd","category":"page"},{"location":"#RollingFunctions.jl","page":"Home","title":"RollingFunctions.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#This-package-makes-it-easy-to-summarize-windowed-data.","page":"Home","title":"This package makes it easy to summarize windowed data.","text":"","category":"section"},{"location":"#A-function-is-applied-to-successive-data-subsequences.","page":"Home","title":"A function is applied to successive data subsequences.","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"You give a summarizing function Func, the data Data, and a window span Span.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The result ‚Ñõ is of length ‚Ñõ·¥∫, ‚Ñõ·¥∫ = length(Data) - Span + 1`.","category":"page"},{"location":"","page":"Home","title":"Home","text":"the result omits ‚Ñõ·¥º, ‚Ñõ·¥º =Span- 1 indices into Data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#*there-are-ways-for-the-results-match-the-data-in-length*","page":"Home","title":"there are ways for the results match the data in length","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Use-a-single,-shared-padding-value","page":"Home","title":"Use a single, shared padding value","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"rolling(function, data, window_span; padding = missing)\nthis will fill the initial result values with the padding value\npads these values (result[1], .., result[pad_nindices])\nrolling(function, data, window_span; padding = missing, padlast = true)\nthis will fill the final result values with the padding value\npads these values (result[n-pad_nindices+1], .., result[n])","category":"page"},{"location":"#Pad-with-a-vector-of-values-with-length-matching-the-extra-indicies-(‚Ñõ·¥º)","page":"Home","title":"Pad with a vector of values with length matching the extra indicies (‚Ñõ·¥º)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"this fills the extra indices with values obtained by copying","category":"page"},{"location":"#Use-an-empty-vector","page":"Home","title":"Use an empty vector","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"this fills the extra indices with values obtained by trimming\ntrimming evaluates the window function over available data\ntrimmed window spans are less than the specified window_span","category":"page"},{"location":"#Use-a-vector-of-ùìÉ-padding-values","page":"Home","title":"Use a vector of ùìÉ padding values","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"where 1 <= ùìÉ < ‚Ñõ·¥º.\nthis first pads then trims to assign the extra indices\nthe first ùìÉ indices of the result will match this vector\nthe next ‚Ñõ·¥º - ùìÉ indices of the result will be trimmed\nthe remaining indices get the rolled results.","category":"page"},{"location":"intro/windoweddata/","page":"-","title":"-","text":"(Windowed Data)","category":"page"}]
}
