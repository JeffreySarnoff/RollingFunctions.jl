var documenterSearchIndex = {"docs":
[{"location":"intro/running/","page":"-","title":"-","text":"You have a data sequence ğ’Ÿ, for our initial purposes it is a Vector [1, 2, 3, 4, 5]. The span of each subsequence is 3. The function to be applied over subsequences of ğ’Ÿ is sum.","category":"page"},{"location":"intro/running/","page":"-","title":"-","text":"using RollingFunctions\n\nğ’Ÿ = [1, 2, 3, 4, 5]\nâ„± = sum\nğ’² = 3\n\nresult = running(â„±, ğ’Ÿ, ğ’²)\njulia> result\n3-element Vector{Int64}:\n  6\n  9\n 12\n\n#=\nThe first  windowed value is the â„± (`sum`) of the first  ğ’² (`3`) values in ğ’Ÿ.\nThe second windowed value is the â„± (`sum`) of the second ğ’² (`3`) values in ğ’Ÿ.\nThe third  windowed value is the â„± (`sum`) of the third  ğ’² (`3`) values in ğ’Ÿ.\n\nThere can be no fourth value as the third value used the fins entries in ğ’Ÿ.\n=#\n\njulia> sum(ğ’Ÿ[1:3]), sum(ğ’Ÿ[2:4]), sum(ğ’Ÿ[3:5])\n(6, 9, 12)\nIf the span of each subsequence increases to 4..\n\nğ’² = 4\nresult = running(â„±, ğ’Ÿ, ğ’²);\n\nresult\n2-element Vector{Int64}:\n 10\n 14","category":"page"},{"location":"intro/running/","page":"-","title":"-","text":"Generally, with data that has r rows using a window_span of w results in r - w + 1 rows of values.","category":"page"},{"location":"references/","page":"References","title":"References","text":"references","category":"page"},{"location":"references/","page":"References","title":"References","text":"abcd","category":"page"},{"location":"tech/windowsorts/","page":"window sorts","title":"window sorts","text":"There are two distinct sorts of windows that are taken over data: rolling and tiled.  Rolling windows advance step-by-step over the data, each step advances the indices spanned by 1 (usually).  Tiled windows advance in larger steps (a multistep) over the data, each multistep advances the indices spanned by a preset amount, the length of the multistep.  ","category":"page"},{"location":"tech/windowsorts/","page":"window sorts","title":"window sorts","text":"With tiled windows, the tiling (the span that describes the indices covered by each tile) and the multistep increment are usually the the same. An example is summarizing a week of daily data and then moving to the following week.  To use a multistep increment that is shorter than the tiling is permitted, as is the use of an increment that is longer than the the tiling â€“ although that is rarely needed.  An example might be summarizing a week of daily data and the skipping over the next week, moving to the second week following for some analytic purpose.","category":"page"},{"location":"api/run/#*run*","page":"run","title":"run","text":"","category":"section"},{"location":"api/run/","page":"run","title":"run","text":"abcd","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"You have a data sequence ğ’Ÿ, it is a Vector [1, 2, 3, 4, 5].\nThe span of each subsequence is 3.\nThe function to be applied over subsequences of ğ’Ÿ is `sum`.","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"using RollingFunctions\n\nğ’Ÿ = [1, 2, 3, 4, 5]\nâ„± = sum\nğ’² = 3\n\nresult = rolling(â„±, ğ’Ÿ, ğ’²)\njulia> result\n3-element Vector{Int64}:\n  6\n  9\n 12\n\n#=\nThe first  windowed value is the â„± (`sum`) of the first  ğ’² (`3`) values in ğ’Ÿ.\nThe second windowed value is the â„± (`sum`) of the second ğ’² (`3`) values in ğ’Ÿ.\nThe third  windowed value is the â„± (`sum`) of the third  ğ’² (`3`) values in ğ’Ÿ.\n\nThere can be no fourth value as the third value used the fins entries in ğ’Ÿ.\n=#\n\njulia> sum(ğ’Ÿ[1:3]), sum(ğ’Ÿ[2:4]), sum(ğ’Ÿ[3:5])\n(6, 9, 12)\nIf the span of each subsequence increases to 4..\n\nğ’² = 4\nresult = rolling(â„±, ğ’Ÿ, ğ’²);\n\nresult\n2-element Vector{Int64}:\n 10\n 14","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"Data with r rows using a window_span of w results in r - w + 1 values.","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"to obtain r values, use padding or tapering","category":"page"},{"location":"tech/arity/","page":"function arity","title":"function arity","text":"Function Arities","category":"page"},{"location":"tech/arity/","page":"function arity","title":"function arity","text":"abcd","category":"page"},{"location":"intro/matrix_rolling/","page":"Rolling over Data Matricies (basics)","title":"Rolling over Data Matricies (basics)","text":"You have n data vectors of equal length (rowcount ğ“‡)\n`ğ’Ÿâ‚ .. ğ’Ÿáµ¢ ..  ğ’Ÿâ‚™`  collected as an ğ“‡ x ğ“ƒ matrix â„³\nyou want to apply the same function (sum) \nto subsequences of each column using a window_span of 3","category":"page"},{"location":"intro/matrix_rolling/","page":"Rolling over Data Matricies (basics)","title":"Rolling over Data Matricies (basics)","text":"using RollingFunctions\n\nğ’Ÿâ‚ = [1, 2, 3, 4, 5]\nğ’Ÿâ‚‚ = [5, 4, 3, 2, 1]\nğ’Ÿâ‚ƒ = [1, 2, 3, 2, 1]\n\nâ„³ = hcat(ğ’Ÿâ‚, ğ’Ÿâ‚‚, ğ’Ÿâ‚ƒ)\n#=\n5Ã—3 Matrix{Int64}:\n 1  5  1\n 2  4  2\n 3  3  3\n 4  2  2\n 5  1  1\n=#\n\nâ„± = sum\nğ’² = 3\n\nresult = rolling(â„±, â„³, ğ’²)\n#=\n3Ã—3 Matrix{Int64}:\n  6  12  6\n  9   9  7\n 12   6  6\n=#\n","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"You may pad the result with the padding value of your choice","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"padding is a keyword argument","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"if you assign e.g. padding = missing, the result will be padded\nyou may pad using any defined value and all types except Nothing\nexample pads (missing, 0, nothing, NaN, 'âˆ…', AbstractString)","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"using RollingFunctions\n\nğ’Ÿâ‚ = [1, 2, 3, 4, 5]\nğ’Ÿâ‚‚ = [5, 4, 3, 2, 1]\n\nâ„± = cov\nğ’² = 3\n\nresult = rolling(â„±, ğ’Ÿâ‚, ğ’Ÿâ‚‚, ğ’²; padding = zero(eltype(â„³)))\n#=\n5 element Vector {Float64}:\n  0.0\n  0.0\n -1.0\n -1.0\n -1.0\n=#","category":"page"},{"location":"intro/multicolumn_padding/#Give-me-the-real-values-first,-pad-to-the-end.","page":"Rolling over multicolumn data (padding)","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"result = rolling(â„±, ğ’Ÿâ‚, ğ’Ÿâ‚‚, ğ’²; padding = missing, padlast=true)\n#=\n5 element Vector {Float64}:\n -1.0\n -1.0\n -1.0\n  missing\n  missing\n=#","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"technical aside: this is not the same as reverse(rolling(â„±, ğ’Ÿâ‚, ğ’Ÿâ‚‚, ğ’²; padding = missing).","category":"page"},{"location":"thanks/","page":"Thanks","title":"Thanks","text":"There have been many who contributed.  These few have done more than most, some without trying. I am grateful.","category":"page"},{"location":"thanks/","page":"Thanks","title":"Thanks","text":"name at\nEliot Saba @staticfloat\nBogumiÅ‚ KamiÅ„ski @bkamins\nKevin Patel @kevindirect","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"ğ’Ÿ ğ’Ÿâ‚—â‚‘â‚™ ğ’² ğ’²â‚—â‚‘â‚™  ğ’¯ ğ’¯â‚—â‚‘â‚™  ğ’« ğ’«â‚—â‚‘â‚™  ğ’ª ğ’ªâº ğ’ªâ»","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"ğ’Ÿ ğ’Ÿâ‚™ ğ’² ğ’²â‚™  ğ’¯ ğ’¯â‚™  ğ’« ğ’«â‚™  ğ’ª ğ’ªâº ğ’ªâ» âºğ’ªâ‚™ â»ğ’ªâ‚™","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"We accept a data sequence ğ’Ÿğ’® of type Vector{T} and of length ğ’Ÿğ’®â‚™ (ğ’Ÿğ’®[begin:end], length(ğ’Ÿğ’®) == ğ’Ÿğ’®â‚™). We are given a window specification that includes its length, the span of any tiling, and more.","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"Given a data seqeunce of N elements and a window that spans W elements (W <= N),     ccompletewindows, rremainingindices = fldmod(N, W)     if iszero(remainingelements) the data sequence is covered exactly with ccompletewindows     otherwise, the data sequence is nearly fully covered with ccompletewindows, leaving rremaining_indices","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"N = c_complete_windows * W + r_remaining_indices\n0 = c_complete_windows * W + r_remaining_indices - N\nc_complete_windows * W = N - r_remaining_indices\nc_complete_windows = div((N - r_remaining_indices), W)\nW = div((N - r_remaining_indices), c_complete_windows)\nr_remaining_indices = N - c_complete_windows * W","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"The preceeding assumes that the window always advances by 1 index. Use A as the whole number of indices (1 <= A <= N-1-W) that window always advances. With A = N-1-W, there is exactly one advance, from index 1 to index 1+N-1-W = N-W    the repositioned window now starts at index N-W and spans W indices, N-W+W == N    and the window has nowhere more to traverse.","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"What value of A allows exactly 2 advances?     A1 = N-1-W, if iseven(A1) A2 = div(A1,2)     or, if isodd(N-W), A2 = div(N-W-1, 2)","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"You may pad the result with the padding value of your choice","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"padding is a keyword argument","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"if you assign e.g. padding = missing, the result will be padded\nyou may pad using any defined value and all types except Nothing\nexample pads (missing, 0, nothing, NaN, 'âˆ…', AbstractString)","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"using RollingFunctions\n\nğ’Ÿâ‚ = [1, 2, 3, 4, 5]\nğ’Ÿâ‚‚ = [5, 4, 3, 2, 1]\nğ’Ÿâ‚ƒ = [1, 2, 3, 2, 1]\n\nâ„³ = hcat(ğ’Ÿâ‚, ğ’Ÿâ‚‚, ğ’Ÿâ‚ƒ)\n#=\n5Ã—3 Matrix{Int64}:\n 1  5  1\n 2  4  2\n 3  3  3\n 4  2  2\n 5  1  1\n=#\n\nâ„± = sum\nğ’² = 3\n\nresult = rolling(â„±, â„³, ğ’²; padding=missing)\n#=\n5Ã—3 Matrix{Union{Missing,Int64}}:\nmissing missing missing\nmissing missing missing\n  6  12  6\n  9   9  7\n 12   6  6\n=#","category":"page"},{"location":"intro/matrix_padding/#Give-me-the-real-values-first,-pad-to-the-end.","page":"Rolling over Data Matrices (padding)","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"result = rolling(â„±, â„³, ğ’²; padding = missing, padlast=true)\n#=\n5Ã—3 Matrix{Union{Missing,Int64}}:\n  6  12  6\n  9   9  7\n 12   6  6\n   missing    missing   missing\n   missing    missing   missing\n=#","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"technical aside: this is not the same as reverse(rolling(ğ’®, ğ’Ÿ, ğ’²; padding = missing).","category":"page"},{"location":"intro/multicolumn_rolling/","page":"Rolling over multicolumn data (basics)","title":"Rolling over multicolumn data (basics)","text":"You have n data vectors of equal length (rowcount ğ“‡)\n`ğ’Ÿâ‚ .. ğ’Ÿáµ¢ ..  ğ’Ÿâ‚™`\nyou want to apply a function of n arguments\nhere, n = 2 and the function is `StatsBase.cor`\nto subsequences over the vectors using a window_span of 3","category":"page"},{"location":"intro/multicolumn_rolling/","page":"Rolling over multicolumn data (basics)","title":"Rolling over multicolumn data (basics)","text":"using RollingFunctions\n\nğ’Ÿâ‚ = [1, 2, 3, 4, 5]\nğ’Ÿâ‚‚ = [5, 4, 3, 2, 1]\n\nâ„± = cor\nğ’² = 3\n\nresult = rolling(â„±, ğ’Ÿâ‚, ğ’Ÿâ‚‚, ğ’²)\n#=\n3-element Vector{Float64}:\n  -1.0\n  -1.0\n  -1.0\n=#","category":"page"},{"location":"tech/windows/#Window-Representations","page":"window structs","title":"Window Representations","text":"","category":"section"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"Multiple structs are used internally to model the constructive details and applicative rules for a Window over client data. All inherit from AbstractWindowing","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"abstract type AbstractWindow end\n\n@kwdef mutable struct BasicWindow <: AbstractWindow\n    const length::Int              # span of contiguous elements\n    \n    direct::Bool=true              # process from low indices to high\n\n    const onlywhole::Bool=true     # prohibit partial window\n    const drop_first::Bool=true    # omit results at startÂ¹, if neededÂ²\n    const drop_final::Bool=false   # omit results at finishÂ¹, if neededÂ²\nend","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"@kwdef mutable struct Window{T} <: AbstractWindow\n    const length::Int              # span of contiguous elements\n    \n    offset_first::Int=0            # start  at index offset_first + 1\n    offset_final::Int=0            # finish at index length - offset_final + 1\n\n    pad_first::Int=0               # pad with this many paddings at start\n    pad_final::Int=0               # pad with this many padding at end\n    const padding::T=nothing       # use this as the value with which to pad\n\n    const direct::Bool=true        # process from low indices to high\n\n    const onlywhole::Bool=true     # prohibit partial windows\n    const drop_first::Bool=true    # omit results at startÂ¹, if neededÂ²\n    const drop_final::Bool=false   # omit results at finishÂ¹, if neededÂ²\n\n    const trim_first::Bool=false   # use partial windowing over first elements, if needed\n    const trim_final::Bool=false   # use partial windowing over final elements, if needed\n    \n    const fill_first::Bool=true    # a simpler, often faster alternative to trim\n    const fill_final::Bool=false   # a simpler, often faster alternative to trim\nend\n\n# is indexing to be offset\nnotoffset(w::Window) = iszero(w.offset_first) && iszero(w.offset_final)\nisoffset(w::Window) = !notoffset(w)\n# >> specifying both a leading offset and a trailing offset is supported\n\n# is there to be padding\nnotpadded(w::Window) = iszero(w.pad_first) && iszero(w.pad_final)\nispadded(w::Window) = !notpadded(w)\n# >> it is an error to specify both a leading padding and a trailing padding\n\n# is the information processed in direct (lower index to higher index) order\nisdirect(w::Window) = w.direct\n\n# are only complete window spans to be allowed\nonlywhole(w::Window) = w.onlywhole\nallowpartial(w::Window) = !onlywhole(w)\n\n# is dropping incomplete results expected\nisdropping(w::Window) = (w.drop_first âŠ» w.drop_final)\nnotdropping(w::Window) = !isdropping(w)\n# >> it is an error to select both `drop_first` and `drop_final`\n  \n# is trimmed windowing to be allowed\nmaytrim(w::Window) = allowspartials(w) && (w.trim_first âŠ» w.trim_last)\n# >> it is an error to select both `trim_first` and `trim_final`\n# >> it is an error to select either `trim` and select any `fill`\n\n# is filled windowing to be allowed\nmayfill(w::Window) = allowspartials(w) && (w.fill_first âŠ» w.fill_last)\n# >> it is an error to select both `fill_first` and `fill_final`\n# >> it is an error to select either `fill` and select any `trim`","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"@kwdef mutable struct WeightedWindow{Pad,F,T} <: AbstractWindow\n    window::Window{Pad}          # struct annotated above\n    weightfun::F=nothing         # a function that yields the weights\n    weighting::Vector{T}         # the weights collected\nend\n\n# the weight function is optional\n# if you specify a weight function, the `weighting` will be autogenerated\n# >> weightings are checked to ensure they sum to 1\n\n----\n","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"Â¹ \"at start\"  is from the lowest  indices where `direct == true`\n              is from the highest indices where `direct == false`\n\n  \"at finish\" is from the highest indices where `direct == true`\n              is from the lowest  indices where `direct == false`\n\nÂ² \"if needed\" is true if and only if `onlywhole == true` and\n              `!iszero(rem(data_length, window_length))`","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"```","category":"page"},{"location":"intro/stepping/","page":"-","title":"-","text":"(Stepping through Windowed Data)","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"This package gives you the ability to apply a summarizing function to successive equilength subsequences of some larger data sequence. You select on a summarizing function â„±, provide the data ğ’Ÿ, and specify a window span ğ’².  By default, ğ’© = length(ğ’Ÿ) - ğ’² + 1 results are returned.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"There are several ways to get as many result values as there are data values:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"specify a padding value (e.g. ; padding = missing)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"this will fill the initial result values with the padding value","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"specify padding to use at the end (e.g. ; padding = missing, padlast = true)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"this will fill the final result values with the padding value","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"specify a vector of padding values (; padding = [1.0, 2.0])","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"this will use the padding values in the order given as the first results\nwhen the length of the padding vector is ğ’©, the result is fully specified\nwhen the length of the padding vector is < ğ’©  â€“ ğ’² - 1 - length(padding) trimmed values fill in after the padding","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"specify an empty, typed vector eltype == eltype(ğ’Ÿ) (; padding = Float64[])","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"this uses the best trimmed values as padding values","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"You may pad the result with the padding value of your choice","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"padding is a keyword argument","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"if you assign e.g. padding = missing, the result will be padded\nyou may pad using any defined value and all types except Nothing\nexample pads (missing, 0, nothing, NaN, 'âˆ…', AbstractString)","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"using RollingFunctions\n\nğ’Ÿ = [1, 2, 3, 4, 5]\nâ„± = sum\nğ’² = 3\n\nresult = rolling(â„±, ğ’Ÿ, ğ’²; padding = missing);\n#=\n5-element Vector{Union{Missing, Int64}}:\n   missing\n   missing\n  6\n  9\n 12\n=#\n \nresult = rolling(â„±, ğ’Ÿ, ğ’²; padding = zero(eltype(ğ’Ÿ));\n#=\n5-element Vector{Int64}:\n  0\n  0\n  6\n  9\n 12\n=#","category":"page"},{"location":"intro/padding/#Give-me-the-real-values-first,-pad-to-the-end.","page":"Rolling over Data (padding)","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"result = rolling(â„±, ğ’Ÿ, ğ’²; padding = missing, padlast=true);\n#=\n5-element Vector{Union{Missing,Int64}}:\n  6\n  9\n 12\n  missing\n  missing\n=#","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"technical aside: this is not the same as reverse(rolling(â„±, ğ’Ÿ, ğ’²; padding = zero(eltype(ğ’Ÿ)).","category":"page"},{"location":"api/roll/#*roll*","page":"roll","title":"roll","text":"","category":"section"},{"location":"api/roll/","page":"roll","title":"roll","text":"abcd","category":"page"},{"location":"#RollingFunctions.jl","page":"Home","title":"RollingFunctions.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You have a data sequence ğ’Ÿ, for now it is a Vector [1, 2, 3, 4, 5].\nThe window span ğ’² of each subsequence is 3.\nThe function â„± to be applied over subsequences of ğ’Ÿ is sum.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using RollingFunctions\n\nğ’Ÿ = [1, 2, 3, 4, 5]\nâ„± = sum\nğ’² = 3\n\nrolled = rolling(â„±, ğ’Ÿ, ğ’²)","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> rolled\n3-element Vector{Int64}:\n  6\n  9\n 12\n\n#=\nThe first  windowed value is the â„± (`sum`) of the first  ğ’² (`3`) values in ğ’Ÿ.\nThe second windowed value is the â„± (`sum`) of the second ğ’² (`3`) values in ğ’Ÿ.\nThe third  windowed value is the â„± (`sum`) of the third  ğ’² (`3`) values in ğ’Ÿ.\n\nThere can be no fourth value as the third value used the fins entries in ğ’Ÿ.\n=#\n\njulia> sum(ğ’Ÿ[1:3]), sum(ğ’Ÿ[2:4]), sum(ğ’Ÿ[3:5])\n(6, 9, 12)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If the span of each subsequence increases to 4..","category":"page"},{"location":"","page":"Home","title":"Home","text":"ğ’² = 4\nrolled = rolling(ğ’Ÿ, ğ’², ğ’®);\n\nrolled\n2-element Vector{Int64}:\n 10\n 14","category":"page"},{"location":"","page":"Home","title":"Home","text":"Generally, with data that has r rows using a window_span of w results in r - w + 1 rows of values.","category":"page"},{"location":"#To-get-back-a-result-with-the-same-number-of-rows-as-your-data","page":"Home","title":"To get back a result with the same number of rows as your data","text":"","category":"section"},{"location":"#Welcome-to-the-wonderful-world-of-padding","page":"Home","title":"Welcome to the wonderful world of padding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You may pad the result with the padding value of your choice","category":"page"},{"location":"","page":"Home","title":"Home","text":"padding is a keyword argument\nif you assign e.g. padding = missing, the result will be padded","category":"page"},{"location":"","page":"Home","title":"Home","text":"missing, 0.0 are commonly used, however all values save Nothing are permitted    â€“ using nothing as the padding is allowed; using the type Nothing is not","category":"page"},{"location":"","page":"Home","title":"Home","text":"using RollingFunctions\n\nğ’Ÿ = [1, 2, 3, 4, 5]\nâ„± = sum\nğ’² = 3\n\nrolled = rolling(â„±, ğ’Ÿ, ğ’²; padding = missing);\n\njulia> rolled\n5-element Vector{Union{Missing, Int64}}:\n   missing\n   missing\n   missing\n 10\n 14\n \nrolled = rolling(ğ’Ÿ, ğ’², ğ’®; padding = zero(eltype(ğ’Ÿ));\njulia> rolled\n5-element Vector{Int64}:\n  0\n  0\n  0\n 10\n 14\n ```\n\n### Give me the real values first, pad to the end.\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"rolled = rolling(â„±, ğ’Ÿ, ğ’²; padding = zero(eltype(ğ’Ÿ), padlast=true); julia> rolled 5-element Vector{Int64}:  10  14   0   0   0 ```","category":"page"},{"location":"","page":"Home","title":"Home","text":"technical note: this is not the same as reverse(rolling(ğ’Ÿ, ğ’², ğ’®; padding = zero(eltype(ğ’Ÿ)).","category":"page"},{"location":"intro/windoweddata/","page":"-","title":"-","text":"(Windowed Data)","category":"page"}]
}
