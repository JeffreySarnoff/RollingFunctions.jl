var documenterSearchIndex = {"docs":
[{"location":"intro/running/","page":"-","title":"-","text":"You have a data sequence 𝐷𝑎𝑡𝑎, for our initial purposes it is a Vector [1, 2, 3, 4, 5]. The span of each subsequence is 3. The function to be applied over subsequences of 𝐷𝑎𝑡𝑎 is sum.","category":"page"},{"location":"intro/running/","page":"-","title":"-","text":"using RollingFunctions","category":"page"},{"location":"intro/running/","page":"-","title":"-","text":"𝐷𝑎𝑡𝑎 = [1, 2, 3, 4, 5] 𝐹𝑢𝑛𝑐 = sum 𝑆𝑝𝑎𝑛 = 3","category":"page"},{"location":"intro/running/","page":"-","title":"-","text":"result = running(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛) julia> result 3-element Vector{Int64}:   6   9  12","category":"page"},{"location":"intro/running/","page":"-","title":"-","text":"#= The first  windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the first  𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎. The second windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the second 𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎. The third  windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the third  𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎.","category":"page"},{"location":"intro/running/","page":"-","title":"-","text":"There can be no fourth value as the third value used the fins entries in 𝐷𝑎𝑡𝑎. =#","category":"page"},{"location":"intro/running/","page":"-","title":"-","text":"julia> sum( 𝐷𝑎𝑡𝑎[1:3]), sum( 𝐷𝑎𝑡𝑎[2:4]), sum( 𝐷𝑎𝑡𝑎[3:5]) (6, 9, 12) If the span of each subsequence increases to 4..","category":"page"},{"location":"intro/running/","page":"-","title":"-","text":"𝑆𝑝𝑎𝑛 = 4 result = running(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛);","category":"page"},{"location":"intro/running/","page":"-","title":"-","text":"result 2-element Vector{Int64}:  10  14","category":"page"},{"location":"intro/running/","page":"-","title":"-","text":"Generally, with data that has r rows using a window_span of w results in r - w + 1 rows of values.","category":"page"},{"location":"references/","page":"References","title":"References","text":"references","category":"page"},{"location":"references/","page":"References","title":"References","text":"abcd","category":"page"},{"location":"tech/windowsorts/","page":"window sorts","title":"window sorts","text":"There are two distinct sorts of windows that are taken over data: rolling and tiled.  Rolling windows advance step-by-step over the data, each step advances the indices spanned by 1 (usually).  Tiled windows advance in larger steps (a multistep) over the data, each multistep advances the indices spanned by a preset amount, the length of the multistep.  ","category":"page"},{"location":"tech/windowsorts/","page":"window sorts","title":"window sorts","text":"With tiled windows, the tiling (the span that describes the indices covered by each tile) and the multistep increment are usually the the same. An example is summarizing a week of daily data and then moving to the following week.  To use a multistep increment that is shorter than the tiling is permitted, as is the use of an increment that is longer than the the tiling – although that is rarely needed.  An example might be summarizing a week of daily data and the skipping over the next week, moving to the second week following for some analytic purpose.","category":"page"},{"location":"api/run/#*run*","page":"run","title":"run","text":"","category":"section"},{"location":"api/run/","page":"run","title":"run","text":"abcd","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"You have a data sequence 𝐷𝑎𝑡𝑎, it is a Vector [1, 2, 3, 4, 5]. The span of each subsequence is 3. The function to be applied over subsequences of 𝐷𝑎𝑡𝑎 issum.","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"using RollingFunctions","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"𝐷𝑎𝑡𝑎 = [1, 2, 3, 4, 5] 𝐹𝑢𝑛𝑐 = sum 𝑆𝑝𝑎𝑛 = 3","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"result = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛) julia> result 3-element Vector{Int64}:   6   9  12","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"#= The first  windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the first  𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎. The second windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the second 𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎. The third  windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the third  𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎.","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"There can be no fourth value as the third value used the fins entries in 𝐷𝑎𝑡𝑎. =#","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"julia> sum( 𝐷𝑎𝑡𝑎[1:3]), sum( 𝐷𝑎𝑡𝑎[2:4]), sum( 𝐷𝑎𝑡𝑎[3:5]) (6, 9, 12) If the span of each subsequence increases to 4..","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"𝑆𝑝𝑎𝑛 = 4 result = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛);","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"result 2-element Vector{Int64}:  10  14","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"Data withr rows using a window_span ofw results inr - w + 1 values.","category":"page"},{"location":"intro/rolling/","page":"Rolling over Data (basics)","title":"Rolling over Data (basics)","text":"to obtainr values, use padding or tapering","category":"page"},{"location":"tech/arity/","page":"function arity","title":"function arity","text":"Function Arities","category":"page"},{"location":"tech/arity/","page":"function arity","title":"function arity","text":"abcd","category":"page"},{"location":"intro/matrix_rolling/","page":"Rolling over Data Matricies (basics)","title":"Rolling over Data Matricies (basics)","text":"You have n data vectors of equal length (rowcount 𝓇)  𝐷𝑎𝑡𝑎₁ .. 𝐷𝑎𝑡𝑎ᵢ ..  𝐷𝑎𝑡𝑎ₙ  collected as an 𝓇 x 𝓃 matrix ℳ you want to apply the same function (sum)  to subsequences of each column using a window_span of 3","category":"page"},{"location":"intro/matrix_rolling/","page":"Rolling over Data Matricies (basics)","title":"Rolling over Data Matricies (basics)","text":"using RollingFunctions","category":"page"},{"location":"intro/matrix_rolling/","page":"Rolling over Data Matricies (basics)","title":"Rolling over Data Matricies (basics)","text":"𝐷𝑎𝑡𝑎₁ = [1, 2, 3, 4, 5]  𝐷𝑎𝑡𝑎₂ = [5, 4, 3, 2, 1]  𝐷𝑎𝑡𝑎₃ = [1, 2, 3, 2, 1]","category":"page"},{"location":"intro/matrix_rolling/","page":"Rolling over Data Matricies (basics)","title":"Rolling over Data Matricies (basics)","text":"ℳ = hcat( 𝐷𝑎𝑡𝑎₁, 𝐷𝑎𝑡𝑎₂, 𝐷𝑎𝑡𝑎₃) #= 5×3 Matrix{Int64}:  1  5  1  2  4  2  3  3  3  4  2  2  5  1  1 =#","category":"page"},{"location":"intro/matrix_rolling/","page":"Rolling over Data Matricies (basics)","title":"Rolling over Data Matricies (basics)","text":"𝐹𝑢𝑛𝑐 = sum 𝑆𝑝𝑎𝑛 = 3","category":"page"},{"location":"intro/matrix_rolling/","page":"Rolling over Data Matricies (basics)","title":"Rolling over Data Matricies (basics)","text":"result = rolling(𝐹𝑢𝑛𝑐, ℳ, 𝑆𝑝𝑎𝑛) #= 3×3 Matrix{Int64}:   6  12  6   9   9  7  12   6  6 =#","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"You may pad the result with the padding value of your choice","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"padding is a keyword argument","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"if you assign e.g. padding = missing, the result will be padded\nyou may pad using any defined value and all types except Nothing\nexample pads(missing, 0, nothing, NaN, '∅', AbstractString)","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"using RollingFunctions","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"𝐷𝑎𝑡𝑎₁ = [1, 2, 3, 4, 5]  𝐷𝑎𝑡𝑎₂ = [5, 4, 3, 2, 1]","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"𝐹𝑢𝑛𝑐 = cov 𝑆𝑝𝑎𝑛 = 3","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"result = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎₁, 𝐷𝑎𝑡𝑎₂, 𝑆𝑝𝑎𝑛; padding = zero(eltype(ℳ))) #= 5 element Vector {Float64}:   0.0   0.0  -1.0  -1.0  -1.0 =#","category":"page"},{"location":"intro/multicolumn_padding/#Give-me-the-real-values-first,-pad-to-the-end.","page":"Rolling over multicolumn data (padding)","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"result = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎₁, 𝐷𝑎𝑡𝑎₂, 𝑆𝑝𝑎𝑛; padding = missing, padlast=true) #= 5 element Vector {Float64}:  -1.0  -1.0  -1.0   missing   missing =#","category":"page"},{"location":"intro/multicolumn_padding/","page":"Rolling over multicolumn data (padding)","title":"Rolling over multicolumn data (padding)","text":"technical aside: this is not the same as reverse(rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎₁, 𝐷𝑎𝑡𝑎₂, 𝑆𝑝𝑎𝑛; padding = missing).","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"","category":"page"},{"location":"use/runoverdata/#This-package-makes-it-easy-to-summarize-windowed-data.","page":"Running over windowed data","title":"This package makes it easy to summarize windowed data.","text":"","category":"section"},{"location":"use/runoverdata/#A-function-is-applied-to-successive-data-subsequences.","page":"Running over windowed data","title":"A function is applied to successive data subsequences.","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"You give a summarizing function 𝐹𝑢𝑛𝑐, the data 𝐷𝑎𝑡𝑎, and a window span 𝑆𝑝𝑎𝑛.  ","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"The result  𝑅 is of length  𝑅ᴺ,   𝑅ᴺ = length( 𝐷𝑎𝑡𝑎) - 𝑆𝑝𝑎𝑛 + 1.","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"the result omits  𝑅ᴼ = 𝑆𝑝𝑎𝑛 - 1 indices that 𝐷𝑎𝑡𝑎 uses.","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"","category":"page"},{"location":"use/runoverdata/#*ways-to-get-as-many-results-as-there-are-data-values*","page":"Running over windowed data","title":"ways to get as many results as there are data values","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"","category":"page"},{"location":"use/runoverdata/#Use-a-vector-of-padding-values-with-length-𝑅ᴼ","page":"Running over windowed data","title":"Use a vector of padding values with length  𝑅ᴼ","text":"","category":"section"},{"location":"use/runoverdata/#specify-a-padding-vector-(default-is-at-the-start)","page":"Running over windowed data","title":"specify a padding vector (default is at the start)","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"here is the way to do that\nrunning(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = [<values>])\nrunning(function, data, window_span; padding = [<values>])","category":"page"},{"location":"use/runoverdata/#specify-the-padding-vector-to-be-at-the-end","page":"Running over windowed data","title":"specify the padding vector to be at the end","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"here is the way to do that\nrunning(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = [<values>], padlast = true)\nrunning(function, data, window_span; padding = [<values>], padlast = true)","category":"page"},{"location":"use/runoverdata/#Use-an-empty-vector","page":"Running over windowed data","title":"Use an empty vector","text":"","category":"section"},{"location":"use/runoverdata/#this-fills-the-𝑅ᴼ-indices-by-trimming","page":"Running over windowed data","title":"this fills the  𝑅ᴼ indices by trimming","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"here is the way to do that\nrunning(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = eltype( 𝐷𝑎𝑡𝑎)[])\nrunning(function, data, window_span; padding = eltype( 𝐷𝑎𝑡𝑎)[])","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"-trimming evaluates the window function over available data","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"trimmed window spans are less than the specified window_span","category":"page"},{"location":"use/runoverdata/#Use-a-vector-of𝓃-padding-values","page":"Running over windowed data","title":"Use a vector of𝓃 padding values","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"where1 <= 𝓃 <   𝑅ᴼ.","category":"page"},{"location":"use/runoverdata/#this-both-pads-and-trims-to-assign-the-initial-indices","page":"Running over windowed data","title":"this both pads and trims to assign the initial indices","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"the first𝓃 indices of the result will match this vector\nthe next  𝑅ᴼ - 𝓃 indices of the result will be trimmed\nthe remaining indices get the rolled results.","category":"page"},{"location":"thanks/","page":"Thanks","title":"Thanks","text":"There have been many who contributed.  These few have done more than most, some without trying. I am grateful.","category":"page"},{"location":"thanks/","page":"Thanks","title":"Thanks","text":"name at\nEliot Saba @staticfloat\nBogumił Kamiński @bkamins\nKevin Patel @kevindirect","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"𝐷𝑎𝑡𝑎 𝐷𝑎𝑡𝑎ₗₑₙ 𝑆𝑝𝑎𝑛 𝑆𝑝𝑎𝑛ₗₑₙ  𝒯 𝒯ₗₑₙ  𝒫 𝒫ₗₑₙ  𝒪 𝒪⁺ 𝒪⁻","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"𝐷𝑎𝑡𝑎 𝐷𝑎𝑡𝑎ₙ 𝑆𝑝𝑎𝑛 𝑆𝑝𝑎𝑛ₙ  𝒯 𝒯ₙ  𝒫 𝒫ₙ  𝒪 𝒪⁺ 𝒪⁻ ⁺𝒪ₙ ⁻𝒪ₙ","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"We accept a data sequence 𝐷𝑎𝑡𝑎𝒮 of type Vector{T} and of length 𝐷𝑎𝑡𝑎𝒮ₙ ( 𝐷𝑎𝑡𝑎𝒮[begin:end], length( 𝐷𝑎𝑡𝑎𝒮) == 𝐷𝑎𝑡𝑎𝒮ₙ). We are given a window specification that includes its length, the span of any tiling, and more.","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"Given a data seqeunce of N elements and a window that spans W elements (W <= N),     ccompletewindows, rremainingindices = fldmod(N, W)     if iszero(remainingelements) the data sequence is covered exactly with ccompletewindows     otherwise, the data sequence is nearly fully covered with ccompletewindows, leaving rremaining_indices","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"N = c_complete_windows * W + r_remaining_indices\n0 = c_complete_windows * W + r_remaining_indices - N\nc_complete_windows * W = N - r_remaining_indices\nc_complete_windows = div((N - r_remaining_indices), W)\nW = div((N - r_remaining_indices), c_complete_windows)\nr_remaining_indices = N - c_complete_windows * W","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"The preceeding assumes that the window always advances by 1 index. Use A as the whole number of indices (1 <= A <= N-1-W) that window always advances. With A = N-1-W, there is exactly one advance, from index 1 to index 1+N-1-W = N-W    the repositioned window now starts at index N-W and spans W indices, N-W+W == N    and the window has nowhere more to traverse.","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"What value of A allows exactly 2 advances?     A1 = N-1-W, if iseven(A1) A2 = div(A1,2)     or, if isodd(N-W), A2 = div(N-W-1, 2)","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"","category":"page"},{"location":"use/rolloverdata/#This-package-makes-it-easy-to-summarize-windowed-data.","page":"Rolling over windowed data","title":"This package makes it easy to summarize windowed data.","text":"","category":"section"},{"location":"use/rolloverdata/#A-function-is-applied-to-successive-data-subsequences.","page":"Rolling over windowed data","title":"A function is applied to successive data subsequences.","text":"","category":"section"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"You give a summarizing function 𝐹𝑢𝑛𝑐, the data 𝐷𝑎𝑡𝑎, and a window span 𝑆𝑝𝑎𝑛.  ","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"The result    𝑅 is of length   𝑅ᴺ","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"𝑅ᴺ = length( 𝐷𝑎𝑡𝑎) - 𝑆𝑝𝑎𝑛 + 1.\nthe result omits 𝑅ᴼ = 𝑆𝑝𝑎𝑛 - 1 indices that 𝐷𝑎𝑡𝑎 uses.\nhere is the way to do that\nrolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛)\nrolling(function, data, window_span)","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"","category":"page"},{"location":"use/rolloverdata/#*ways-to-get-as-many-results-as-there-are-data-values*","page":"Rolling over windowed data","title":"ways to get as many results as there are data values","text":"","category":"section"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"","category":"page"},{"location":"use/rolloverdata/#Use-a-single,-shared-padding-value","page":"Rolling over windowed data","title":"Use a single, shared padding value","text":"","category":"section"},{"location":"use/rolloverdata/#specify-a-padding-value-(default-position-is-at-the-start)","page":"Rolling over windowed data","title":"specify a padding value (default position is at the start)","text":"","category":"section"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"here is the way to do that\nrolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = \\<value\\>)\nrolling(function, data, window_span; padding = missing)\nthis will fill the initial result values with the padding value\npads these values(result[1], .., result[pad_nindices])","category":"page"},{"location":"use/rolloverdata/#specify-padding-to-be-at-the-end-of-the-result","page":"Rolling over windowed data","title":"specify padding to be at the end of the result","text":"","category":"section"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"here is the way to do that\nrolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = <value>, padlast = true)\nrolling(function, data, window_span; padding = missing, padlast = true)\nthis will fill the final result values with the padding value\npads these values(result[n-pad_nindices+1], .., result[n])","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"You may pad the result with the padding value of your choice","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"padding is a keyword argument","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"if you assign e.g. padding = missing, the result will be padded\nyou may pad using any defined value and all types except Nothing\nexample pads(missing, 0, nothing, NaN, '∅', AbstractString)","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"using RollingFunctions","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"𝐷𝑎𝑡𝑎₁ = [1, 2, 3, 4, 5]  𝐷𝑎𝑡𝑎₂ = [5, 4, 3, 2, 1]  𝐷𝑎𝑡𝑎₃ = [1, 2, 3, 2, 1]","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"ℳ = hcat( 𝐷𝑎𝑡𝑎₁, 𝐷𝑎𝑡𝑎₂, 𝐷𝑎𝑡𝑎₃) #= 5×3 Matrix{Int64}:  1  5  1  2  4  2  3  3  3  4  2  2  5  1  1 =#","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"𝐹𝑢𝑛𝑐 = sum 𝑆𝑝𝑎𝑛 = 3","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"result = rolling(𝐹𝑢𝑛𝑐, ℳ, 𝑆𝑝𝑎𝑛; padding=missing) #= 5×3 Matrix{Union{Missing,Int64}}: missing missing missing missing missing missing   6  12  6   9   9  7  12   6  6 =#","category":"page"},{"location":"intro/matrix_padding/#Give-me-the-real-values-first,-pad-to-the-end.","page":"Rolling over Data Matrices (padding)","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"result = rolling(𝐹𝑢𝑛𝑐, ℳ, 𝑆𝑝𝑎𝑛; padding = missing, padlast=true) #= 5×3 Matrix{Union{Missing,Int64}}:   6  12  6   9   9  7  12   6  6    missing    missing   missing    missing    missing   missing =#","category":"page"},{"location":"intro/matrix_padding/","page":"Rolling over Data Matrices (padding)","title":"Rolling over Data Matrices (padding)","text":"technical aside: this is not the same as reverse(rolling(𝒮, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = missing).","category":"page"},{"location":"intro/multicolumn_rolling/","page":"Rolling over multicolumn data (basics)","title":"Rolling over multicolumn data (basics)","text":"You have n data vectors of equal length (rowcount 𝓇)  𝐷𝑎𝑡𝑎₁ .. 𝐷𝑎𝑡𝑎ᵢ ..  𝐷𝑎𝑡𝑎ₙ you want to apply a function of n arguments here, n = 2 and the function isStatsBase.cor to subsequences over the vectors using a window_span of 3","category":"page"},{"location":"intro/multicolumn_rolling/","page":"Rolling over multicolumn data (basics)","title":"Rolling over multicolumn data (basics)","text":"using RollingFunctions","category":"page"},{"location":"intro/multicolumn_rolling/","page":"Rolling over multicolumn data (basics)","title":"Rolling over multicolumn data (basics)","text":"𝐷𝑎𝑡𝑎₁ = [1, 2, 3, 4, 5]  𝐷𝑎𝑡𝑎₂ = [5, 4, 3, 2, 1]","category":"page"},{"location":"intro/multicolumn_rolling/","page":"Rolling over multicolumn data (basics)","title":"Rolling over multicolumn data (basics)","text":"𝐹𝑢𝑛𝑐 = cor 𝑆𝑝𝑎𝑛 = 3","category":"page"},{"location":"intro/multicolumn_rolling/","page":"Rolling over multicolumn data (basics)","title":"Rolling over multicolumn data (basics)","text":"result = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎₁, 𝐷𝑎𝑡𝑎₂, 𝑆𝑝𝑎𝑛) #= 3-element Vector{Float64}:   -1.0   -1.0   -1.0 =#","category":"page"},{"location":"tech/windows/#Window-Representations","page":"window structs","title":"Window Representations","text":"","category":"section"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"Multiple structs are used internally to model the constructive details and applicative rules for a Window over client data. All inherit from AbstractWindowing","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"abstract type AbstractWindow end","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"@kwdef mutable struct BasicWindow <: AbstractWindow     const length::Int              # span of contiguous elements","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"direct::Bool=true              # process from low indices to high\n\nconst onlywhole::Bool=true     # prohibit partial window\nconst drop_first::Bool=true    # omit results at start¹, if needed²\nconst drop_final::Bool=false   # omit results at finish¹, if needed²","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"end","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"@kwdef mutable struct Window{T} <: AbstractWindow     const length::Int              # span of contiguous elements","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"offset_first::Int=0            # start  at index offset_first + 1\noffset_final::Int=0            # finish at index length - offset_final + 1\n\npad_first::Int=0               # pad with this many paddings at start\npad_final::Int=0               # pad with this many padding at end\nconst padding::T=nothing       # use this as the value with which to pad\n\nconst direct::Bool=true        # process from low indices to high\n\nconst onlywhole::Bool=true     # prohibit partial windows\nconst drop_first::Bool=true    # omit results at start¹, if needed²\nconst drop_final::Bool=false   # omit results at finish¹, if needed²\n\nconst trim_first::Bool=false   # use partial windowing over first elements, if needed\nconst trim_final::Bool=false   # use partial windowing over final elements, if needed\n\nconst fill_first::Bool=true    # a simpler, often faster alternative to trim\nconst fill_final::Bool=false   # a simpler, often faster alternative to trim","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"end","category":"page"},{"location":"tech/windows/#is-indexing-to-be-offset","page":"window structs","title":"is indexing to be offset","text":"","category":"section"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"notoffset(w::Window) = iszero(w.offsetfirst) && iszero(w.offsetfinal) isoffset(w::Window) = !notoffset(w)","category":"page"},{"location":"tech/windows/#specifying-both-a-leading-offset-and-a-trailing-offset-is-supported","page":"window structs","title":">> specifying both a leading offset and a trailing offset is supported","text":"","category":"section"},{"location":"tech/windows/#is-there-to-be-padding","page":"window structs","title":"is there to be padding","text":"","category":"section"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"notpadded(w::Window) = iszero(w.padfirst) && iszero(w.padfinal) ispadded(w::Window) = !notpadded(w)","category":"page"},{"location":"tech/windows/#it-is-an-error-to-specify-both-a-leading-padding-and-a-trailing-padding","page":"window structs","title":">> it is an error to specify both a leading padding and a trailing padding","text":"","category":"section"},{"location":"tech/windows/#is-the-information-processed-in-direct-(lower-index-to-higher-index)-order","page":"window structs","title":"is the information processed in direct (lower index to higher index) order","text":"","category":"section"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"isdirect(w::Window) = w.direct","category":"page"},{"location":"tech/windows/#are-only-complete-window-spans-to-be-allowed","page":"window structs","title":"are only complete window spans to be allowed","text":"","category":"section"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"onlywhole(w::Window) = w.onlywhole allowpartial(w::Window) = !onlywhole(w)","category":"page"},{"location":"tech/windows/#is-dropping-incomplete-results-expected","page":"window structs","title":"is dropping incomplete results expected","text":"","category":"section"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"isdropping(w::Window) = (w.dropfirst ⊻ w.dropfinal) notdropping(w::Window) = !isdropping(w)","category":"page"},{"location":"tech/windows/#it-is-an-error-to-select-bothdrop*first-anddrop*final","page":"window structs","title":">> it is an error to select bothdropfirst anddropfinal","text":"","category":"section"},{"location":"tech/windows/#is-trimmed-windowing-to-be-allowed","page":"window structs","title":"is trimmed windowing to be allowed","text":"","category":"section"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"maytrim(w::Window) = allowspartials(w) && (w.trimfirst ⊻ w.trimlast)","category":"page"},{"location":"tech/windows/#it-is-an-error-to-select-bothtrim*first-andtrim*final","page":"window structs","title":">> it is an error to select bothtrimfirst andtrimfinal","text":"","category":"section"},{"location":"tech/windows/#it-is-an-error-to-select-eithertrim-and-select-anyfill","page":"window structs","title":">> it is an error to select eithertrim and select anyfill","text":"","category":"section"},{"location":"tech/windows/#is-filled-windowing-to-be-allowed","page":"window structs","title":"is filled windowing to be allowed","text":"","category":"section"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"mayfill(w::Window) = allowspartials(w) && (w.fillfirst ⊻ w.filllast)","category":"page"},{"location":"tech/windows/#it-is-an-error-to-select-bothfill*first-andfill*final","page":"window structs","title":">> it is an error to select bothfillfirst andfillfinal","text":"","category":"section"},{"location":"tech/windows/#it-is-an-error-to-select-eitherfill-and-select-anytrim","page":"window structs","title":">> it is an error to select eitherfill and select anytrim","text":"","category":"section"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"@kwdef mutable struct WeightedWindow{Pad,F,T} <: AbstractWindow     window::Window{Pad}          # struct annotated above     weightfun::F=nothing         # a function that yields the weights     weighting::Vector{T}         # the weights collected end","category":"page"},{"location":"tech/windows/#the-weight-function-is-optional","page":"window structs","title":"the weight function is optional","text":"","category":"section"},{"location":"tech/windows/#if-you-specify-a-weight-function,-theweighting-will-be-autogenerated","page":"window structs","title":"if you specify a weight function, theweighting will be autogenerated","text":"","category":"section"},{"location":"tech/windows/#weightings-are-checked-to-ensure-they-sum-to-1","page":"window structs","title":">> weightings are checked to ensure they sum to 1","text":"","category":"section"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"","category":"page"},{"location":"tech/windows/","page":"window structs","title":"window structs","text":"¹ \"at start\"  is from the lowest  indices wheredirect == true\n              is from the highest indices wheredirect == false\n\n  \"at finish\" is from the highest indices wheredirect == true\n              is from the lowest  indices wheredirect == false\n\n² \"if needed\" is true if and only ifonlywhole == true and\n             !iszero(rem(data_length, window_length))","category":"page"},{"location":"intro/stepping/","page":"-","title":"-","text":"(Stepping through Windowed Data)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"You have a data sequence 𝐷𝑎𝑡𝑎, for now it is a Vector[1, 2, 3, 4, 5].\nThe window span 𝑆𝑝𝑎𝑛 of each subsequence is3.\nThe function 𝐹𝑢𝑛𝑐 to be applied over subsequences of 𝐷𝑎𝑡𝑎 issum.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using RollingFunctions","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"𝐷𝑎𝑡𝑎 = [1, 2, 3, 4, 5] 𝐹𝑢𝑛𝑐 = sum 𝑆𝑝𝑎𝑛 = 3","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"rolled = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"julia> rolled 3-element Vector{Int64}:   6   9  12","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"#= The first  windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the first  𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎. The second windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the second 𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎. The third  windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the third  𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"There can be no fourth value as the third value used the fins entries in 𝐷𝑎𝑡𝑎. =#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"julia> sum( 𝐷𝑎𝑡𝑎[1:3]), sum( 𝐷𝑎𝑡𝑎[2:4]), sum( 𝐷𝑎𝑡𝑎[3:5]) (6, 9, 12)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"If the span of each subsequence increases to 4..","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"𝑆𝑝𝑎𝑛 = 4 rolled = rolling( 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛, 𝒮);","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"rolled 2-element Vector{Int64}:  10  14","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Generally, with data that has r rows using a window_span of w results in r - w + 1 rows of values.","category":"page"},{"location":"overview/#To-get-back-a-result-with-the-same-number-of-rows-as-your-data","page":"Overview","title":"To get back a result with the same number of rows as your data","text":"","category":"section"},{"location":"overview/#Welcome-to-the-wonderful-world-of-padding","page":"Overview","title":"Welcome to the wonderful world of padding","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"You may pad the result with the padding value of your choice -padding is a keyword argument","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"if you assign e.g.padding = missing, the result will be padded","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"missing, 0.0 are commonly used, however all values saveNothing are permitted    – usingnothing as the padding is allowed; using the typeNothing is not","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using RollingFunctions","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"𝐷𝑎𝑡𝑎 = [1, 2, 3, 4, 5] 𝐹𝑢𝑛𝑐 = sum 𝑆𝑝𝑎𝑛 = 3","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"rolled = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = missing);","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"julia> rolled 5-element Vector{Union{Missing, Int64}}:    missing    missing    missing  10  14","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"rolled = rolling( 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛, 𝒮; padding = zero(eltype( 𝐷𝑎𝑡𝑎)); julia> rolled 5-element Vector{Int64}:   0   0   0  10  14","category":"page"},{"location":"overview/#Give-me-the-real-values-first,-pad-to-the-end.","page":"Overview","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"rolled = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = zero(eltype( 𝐷𝑎𝑡𝑎), padlast=true); julia> rolled 5-element Vector{Int64}:  10  14   0   0   0","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"technical note: this is not the same asreverse(rolling( 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛, 𝒮; padding = zero(eltype( 𝐷𝑎𝑡𝑎)).","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"You may pad the result with the padding value of your choice","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"padding is a keyword argument","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"if you assign e.g. padding = missing, the result will be padded\nyou may pad using any defined value and all types except Nothing\nexample pads(missing, 0, nothing, NaN, '∅', AbstractString)","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"using RollingFunctions","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"𝐷𝑎𝑡𝑎 = [1, 2, 3, 4, 5] 𝐹𝑢𝑛𝑐 = sum 𝑆𝑝𝑎𝑛 = 3","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"result = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = missing); #= 5-element Vector{Union{Missing, Int64}}:    missing    missing   6   9  12 =#","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"result = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = zero(eltype( 𝐷𝑎𝑡𝑎)); #= 5-element Vector{Int64}:   0   0   6   9  12 =#","category":"page"},{"location":"intro/padding/#Give-me-the-real-values-first,-pad-to-the-end.","page":"Rolling over Data (padding)","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"result = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = missing, padlast=true); #= 5-element Vector{Union{Missing,Int64}}:   6   9  12   missing   missing =#","category":"page"},{"location":"intro/padding/","page":"Rolling over Data (padding)","title":"Rolling over Data (padding)","text":"technical aside: this is not the same as reverse(rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = zero(eltype( 𝐷𝑎𝑡𝑎)).","category":"page"},{"location":"api/roll/#*roll*","page":"roll","title":"roll","text":"","category":"section"},{"location":"api/roll/","page":"roll","title":"roll","text":"abcd","category":"page"},{"location":"#RollingFunctions.jl","page":"Home","title":"RollingFunctions.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#This-package-makes-it-easy-to-summarize-windowed-data.","page":"Home","title":"This package makes it easy to summarize windowed data.","text":"","category":"section"},{"location":"#A-function-is-applied-to-successive-data-subsequences.","page":"Home","title":"A function is applied to successive data subsequences.","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"You give a summarizing function 𝐹𝑢𝑛𝑐, the data 𝐷𝑎𝑡𝑎, and a window span 𝑆𝑝𝑎𝑛.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The result  𝑅 is of length   𝑅ᴺ,   𝑅ᴺ = length( 𝐷𝑎𝑡𝑎) - 𝑆𝑝𝑎𝑛 + 1.","category":"page"},{"location":"","page":"Home","title":"Home","text":"the result omits 𝑅ᴼ = 𝑆𝑝𝑎𝑛 - 1 indices into 𝐷𝑎𝑡𝑎.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#*there-are-ways-for-the-results-match-the-data-in-length*","page":"Home","title":"there are ways for the results match the data in length","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Use-a-single,-shared-padding-value","page":"Home","title":"Use a single, shared padding value","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"rolling(function, data, window_span; padding = missing)\nthis will fill the initial result values with the padding value\npads these values(result[1], .., result[pad_nindices])\nrolling(function, data, window_span; padding = missing, padlast = true)\nthis will fill the final result values with the padding value\npads these values(result[n-pad_nindices+1], .., result[n])","category":"page"},{"location":"#Pad-with-a-vector-of-values-with-length-matching-the-extra-indicies-(-𝑅ᴼ)","page":"Home","title":"Pad with a vector of values with length matching the extra indicies (  𝑅ᴼ)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"this fills the extra indices with values obtained bycopying","category":"page"},{"location":"#Use-an-empty-vector","page":"Home","title":"Use an empty vector","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"this fills the extra indices with values obtained bytrimming\ntrimming evaluates the window function over available data\ntrimmed window spans are less than the specified window_span","category":"page"},{"location":"#Use-a-vector-of𝓃-padding-values","page":"Home","title":"Use a vector of𝓃 padding values","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"where1 <= 𝓃 <   𝑅ᴼ.\nthis first pads then trims to assign the extra indices\nthe first𝓃 indices of the result will match this vector\nthe next  𝑅ᴼ - 𝓃 indices of the result will be trimmed\nthe remaining indices get the rolled results.","category":"page"},{"location":"intro/windoweddata/","page":"-","title":"-","text":"(Windowed Data)","category":"page"}]
}
