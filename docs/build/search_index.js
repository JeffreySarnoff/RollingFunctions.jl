var documenterSearchIndex = {"docs":
[{"location":"references/","page":"References","title":"References","text":"references","category":"page"},{"location":"references/","page":"References","title":"References","text":"wavefront (moving and tumbling windows)","category":"page"},{"location":"use/rolling_examples/","page":"Rolling examples (basic)","title":"Rolling examples (basic)","text":"You have a data sequence 𝐷𝑎𝑡𝑎, the Vector[1, 2, 3, 4, 5].\nThe window width 𝑆𝑝𝑎𝑛 of each subsequence is 3.\nThe function 𝐹𝑢𝑛𝑐 to be applied over subsequences of 𝐷𝑎𝑡𝑎 is sum.","category":"page"},{"location":"use/rolling_examples/","page":"Rolling examples (basic)","title":"Rolling examples (basic)","text":"using RollingFunctions\n\n𝐷𝑎𝑡𝑎 = [1, 2, 3, 4, 5]\n𝐹𝑢𝑛𝑐 = sum\n𝑆𝑝𝑎𝑛 = 3\n\nrolled = rolling(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛)\n\n\njulia> rolled\n3-element Vector{Int64}:\n  6\n  9\n 12\n\n#=\nThe first  windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the first  𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎.\nThe second windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the second 𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎.\nThe third  windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the third  𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎.\n\nThere can be no fourth value as the third value used the fins entries in𝐷𝑎𝑡𝑎.\n=#\n\njulia> sum(𝐷𝑎𝑡𝑎[1:3]), sum(𝐷𝑎𝑡𝑎[2:4]), sum(𝐷𝑎𝑡𝑎[3:5])\n(6, 9, 12)\n\n\nIf the width of each subsequence increases to 4..\n\n𝑆𝑝𝑎𝑛 = 4\nrolled = rolling(𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛, 𝒮);\n\nrolled\n2-element Vector{Int64}:\n 10\n 14","category":"page"},{"location":"use/rolling_examples/","page":"Rolling examples (basic)","title":"Rolling examples (basic)","text":"Generally, with data that has r rows using a width of s results in r - s + 1 rows of values.","category":"page"},{"location":"use/rolling_examples/#To-get-back-a-result-with-the-same-number-of-rows-as-your-data","page":"Rolling examples (basic)","title":"To get back a result with the same number of rows as your data","text":"","category":"section"},{"location":"use/rolling_examples/#Welcome-to-the-wonderful-world-of-padding","page":"Rolling examples (basic)","title":"Welcome to the wonderful world of padding","text":"","category":"section"},{"location":"use/rolling_examples/","page":"Rolling examples (basic)","title":"Rolling examples (basic)","text":"You may pad the result with the padding value of your choice","category":"page"},{"location":"use/rolling_examples/","page":"Rolling examples (basic)","title":"Rolling examples (basic)","text":"padding is a keyword argument\nmissing, 0.0 are commonly used\nalmost all values are usable\nusing nothing as the padding is allowed\nusing the type Nothing is disallowed","category":"page"},{"location":"use/rolling_examples/","page":"Rolling examples (basic)","title":"Rolling examples (basic)","text":"using RollingFunctions\n\n𝐷𝑎𝑡𝑎 = [1, 2, 3, 4, 5]\n𝐹𝑢𝑛𝑐 = sum\n𝑆𝑝𝑎𝑛 = 3\n\nrolled = rolling(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = missing);\n\njulia> rolled\n5-element Vector{Union{Missing, Int64}}:\n   missing\n   missing\n   missing\n 10\n 14\n \nrolled = rolling(𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛, 𝒮; padding = zero(eltype(𝐷𝑎𝑡𝑎));\njulia> rolled\n5-element Vector{Int64}:\n  0\n  0\n  0\n 10\n 14","category":"page"},{"location":"use/rolling_examples/#Give-me-the-real-values-first,-pad-to-the-end.","page":"Rolling examples (basic)","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"use/rolling_examples/","page":"Rolling examples (basic)","title":"Rolling examples (basic)","text":"rolled = rolling(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = zero(eltype(𝐷𝑎𝑡𝑎), atend=true);\njulia> rolled\n5-element Vector{Int64}:\n 10\n 14\n  0\n  0\n  0","category":"page"},{"location":"use/rolling_examples/","page":"Rolling examples (basic)","title":"Rolling examples (basic)","text":"technical note: this is not the same asreverse(rolling(𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛, 𝒮; padding = zero(eltype(𝐷𝑎𝑡𝑎)).","category":"page"},{"location":"intro/stepping/","page":"-","title":"-","text":"(Stepping through Windowed Data)","category":"page"},{"location":"approach/rolling/","page":"rolling","title":"rolling","text":"rolling(rolling_fn, window_width, data_seq)\r\n\r\nrolling(rolling_fn, window_width, data_seq;\r\n        padding=nopadding, atend=false)","category":"page"},{"location":"approach/rolling/","page":"rolling","title":"rolling","text":"One step in rolling applies a summarizing, condensing, or exploring function to the data the current window covers.","category":"page"},{"location":"approach/rolling/","page":"rolling","title":"rolling","text":"While the window is fully contained within the data_seq, each step increments the indices of the current window: (start:finish)  ↦  (start+1:finish+1).","category":"page"},{"location":"approach/rolling/","page":"rolling","title":"rolling","text":"When advancing the window would carry the end of the window beyond the end of the data_seq, basic rolling is complete.","category":"page"},{"location":"approach/rolling/","page":"rolling","title":"rolling","text":"rolling allows two keyword args (padding and atend).\npadding (defaults to nopadding)\natend (defaults to false)","category":"page"},{"location":"approach/rolling/","page":"rolling","title":"rolling","text":"\nrolling(fn, width, data)\nrolling(fn, width, data; padding)\nrolling(fn, width, data; atend)\nrolling(fn, width, data; padding, atend)\n","category":"page"},{"location":"approach/rolling/","page":"rolling","title":"rolling","text":"See also: padding,            atend,           weighted,           datastreams","category":"page"},{"location":"design/stratified_internals/#rolling-functions-over-windowed-data","page":"-","title":"rolling functions over windowed data","text":"","category":"section"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"basic rolling\ngiven a data sequence of N elements\nusing a data window that widths S indices\none obtains N - S + 1 result values","category":"page"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"padded rolling\ngiven a data sequence of N elements\nusing a data window that widths S indices\none obtains  N - S + 1 result values\nand provides S - 1 elements that pad","category":"page"},{"location":"design/stratified_internals/#rolling-is-built-from-three-internal-functions","page":"-","title":"rolling is built from three internal functions","text":"","category":"section"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"basic_rolling\nthe result has fewer elements than the data has","category":"page"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"padfirst_rolling\nthe padding elements occupy the lowest indices of the result","category":"page"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"padfinal_rolling\nthe padding elements occupy the highest indices of the result","category":"page"},{"location":"design/stratified_internals/#unweighted-rolling","page":"-","title":"unweighted rolling","text":"","category":"section"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"function rolling(fn1, width, data; padding, atend)\r\n\r\n    if padding === nopadding\r\n       basic_rolling(fn1, width, data)\r\n    elseif !atend\r\n       padfirst_rolling(fn1, width, data, padding)\r\n    else\r\n       padfinal_rolling(fn1, width, data, padding)\r\n    end\r\n\r\nend","category":"page"},{"location":"design/stratified_internals/#weighted-rolling","page":"-","title":"weighted rolling","text":"","category":"section"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"function rolling(fn1, width, data, weights; padding, atend)\r\n\r\n    if padding === nopadding\r\n       basic_rolling(fn1, width, data, weights)\r\n    elseif !atend\r\n       padfirst_rolling(fn1, width, data, weights, padding)\r\n    else\r\n       padfinal_rolling(fn1, width, data, weights, padding)\r\n    end\r\n\r\nend","category":"page"},{"location":"design/stratified_internals/#processing","page":"-","title":"processing","text":"","category":"section"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"unweighted \nthe current window on the data is obtained current_data\nthe function is applied to the current_data rolling_value","category":"page"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"with weights \nthe current window on the data is obtained current_data\nthe current_data is scaled by the weights weighted_data\nthe function is applied to the weighted_data rolling_value","category":"page"},{"location":"design/stratified_internals/#additional-coverage","page":"-","title":"additional coverage","text":"","category":"section"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"There are similar implementations for functions of 2, 3 arguments.","category":"page"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"function rolling(fn2, width, data1, data2; \r\n                padding, atend)\r\n\r\n    if padding === nopadding\r\n       basic_rolling(fn2, width, data1, data2)\r\n    elseif !atend\r\n       padfirst_rolling(fn2, width, data1, data2, padding)\r\n    else\r\n       padfinal_rolling(fn2, width, data1, data2, padding)\r\n    end\r\n\r\nend","category":"page"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"function rolling(fn2, width, data1, data2, weights1, weights2;\r\n                 padding, atend)\r\n\r\n    if padding === nopadding\r\n       basic_rolling(fn2, width, data1, data2,\r\n                                weights1, weights2)\r\n    elseif !atend\r\n       padfirst_rolling(fn2, width, data1, data2, \r\n                                   weights1, weights2, padding)\r\n    else\r\n       padfinal_rolling(fn2, width, data1, data2,\r\n                                   weights1, weights2, padding)\r\n    end\r\n\r\nend","category":"page"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"","category":"page"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"","category":"page"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"signatures returns\nfn1(x) scalar\nfn2(x,y) scalar\nfn3(x,y,z) scalar","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"𝐷𝑎𝑡𝑎𝐷𝑎𝑡𝑎ₗₑₙ 𝑆𝑝𝑎𝑛 𝑆𝑝𝑎𝑛ₗₑₙ  𝒯 𝒯ₗₑₙ  𝒫 𝒫ₗₑₙ  𝒪 𝒪⁺ 𝒪⁻","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"𝐷𝑎𝑡𝑎𝐷𝑎𝑡𝑎ₙ 𝑆𝑝𝑎𝑛 𝑆𝑝𝑎𝑛ₙ  𝒯 𝒯ₙ  𝒫 𝒫ₙ  𝒪 𝒪⁺ 𝒪⁻ ⁺𝒪ₙ ⁻𝒪ₙ","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"We accept a data sequence𝐷𝑎𝑡𝑎𝒮 of type Vector{T} and of length𝐷𝑎𝑡𝑎𝒮ₙ (𝐷𝑎𝑡𝑎𝒮[begin:end], length(𝐷𝑎𝑡𝑎𝒮) ==𝐷𝑎𝑡𝑎𝒮ₙ). We are given a window specification that includes its length, the width of any tiling, and more.","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"Given a data seqeunce of N elements and a window that widths W elements (W <= N),     ccompletewindows, rremainingindices = fldmod(N, W)     if iszero(remainingelements) the data sequence is covered exactly with ccompletewindows     otherwise, the data sequence is nearly fully covered with ccompletewindows, leaving rremaining_indices","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"N = c_complete_windows * W + r_remaining_indices\n0 = c_complete_windows * W + r_remaining_indices - N\nc_complete_windows * W = N - r_remaining_indices\nc_complete_windows = div((N - r_remaining_indices), W)\nW = div((N - r_remaining_indices), c_complete_windows)\nr_remaining_indices = N - c_complete_windows * W","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"The preceeding assumes that the window always advances by 1 index. Use A as the whole number of indices (1 <= A <= N-1-W) that window always advances. With A = N-1-W, there is exactly one advance, from index 1 to index 1+N-1-W = N-W    the repositioned window now starts at index N-W and widths W indices, N-W+W == N    and the window has nowhere more to traverse.","category":"page"},{"location":"tech/windowmath/","page":"windowing math","title":"windowing math","text":"What value of A allows exactly 2 advances?     A1 = N-1-W, if iseven(A1) A2 = div(A1,2)     or, if isodd(N-W), A2 = div(N-W-1, 2)","category":"page"},{"location":"api/rolling/#for-brevity","page":"rolling","title":"for brevity","text":"","category":"section"},{"location":"api/rolling/","page":"rolling","title":"rolling","text":"fn1(x)        is a function of 1 argument,  returns a scalar\nfn2(x, y)     is a function of 2 arguments, returns a scalar\nfn3(x, y, z)  is a function of 3 arguments, returns a scalar","category":"page"},{"location":"api/rolling/","page":"rolling","title":"rolling","text":"const AV  = AbstractVector\nconst PVD = nopadding # padding[value]_default\nconst PLD = false # atend_default","category":"page"},{"location":"api/rolling/#these-are-the-three-foundational-forms-that-roll","page":"rolling","title":"these are the three foundational forms that roll","text":"","category":"section"},{"location":"api/rolling/","page":"rolling","title":"rolling","text":"rolling(fn1, width, data1::V) where {V<:AV}\n\nrolling(fn1, width, data1::V;\n        padding=PVD) where {V<:AV}\n\nrolling(fn1, width, data1::V;\n        padding=PVD, atend=PLD) where {V<:AV}","category":"page"},{"location":"api/rolling/#enhanced-forms-allow-two-or-three-distinct-data-vectors","page":"rolling","title":"enhanced forms allow two or three distinct data vectors","text":"","category":"section"},{"location":"api/rolling/","page":"rolling","title":"rolling","text":"they support summarizing functions that take 2 or 3  args","category":"page"},{"location":"api/rolling/","page":"rolling","title":"rolling","text":"rolling(fn2, width, data1::V, data2::V) where {V<:AV}\n\nrolling(fn2, width, data1::V, data2::V;\n        padding=PVD) where {V<:AV}\n\nrolling(fn2, width, data1::V, data2::V;\n        padding=PVD, atend=PLD) where {V<:AV}","category":"page"},{"location":"api/rolling/","page":"rolling","title":"rolling","text":"rolling(fn3, width, data1::V, data2::V, data3::V) where {V<:AV}\n\nrolling(fn3, width, data1::V, data2::V, data3::V;\n        padding=PVD) where {V<:AV}\n\nrolling(fn3, width, data1::V, data2::V, data3::V;\n        padding=PVD, atend=PLD) where {V<:AV}","category":"page"},{"location":"api/rolling/#given-a-matrix,-the-function-is-applied-to-each-column","page":"rolling","title":"given a matrix, the function is applied to each column","text":"","category":"section"},{"location":"api/rolling/","page":"rolling","title":"rolling","text":"a corresponding matrix is returned","category":"page"},{"location":"api/rolling/","page":"rolling","title":"rolling","text":"rolling(fn1, datamat, width)\n\nrolling(fn1, datamat, width; padding)\n\nrolling(fn1, datamat, width; padding, atend)","category":"page"},{"location":"approach/padding/","page":"-","title":"-","text":"   padding -- optional keyword argument","category":"page"},{"location":"approach/padding/","page":"-","title":"-","text":"By definition, applying a windowed function over data will result in fewer items than are in the original data. To add the missing items, select a padding value using the padding keyword argument e.g. padding=missing.","category":"page"},{"location":"approach/padding/","page":"-","title":"-","text":"By default, padding is applied at the begining of the result.","category":"page"},{"location":"approach/padding/","page":"-","title":"-","text":"by default, the padding value is placed at the lowest indices","category":"page"},{"location":"approach/padding/","page":"-","title":"-","text":"To apply padding at the end of the result, set atend=true.","category":"page"},{"location":"approach/padding/","page":"-","title":"-","text":"that way the padding value is placed at the highest indices","category":"page"},{"location":"approach/padding/","page":"-","title":"-","text":"See also: atend,           rolling,           tiling,           running","category":"page"},{"location":"approach/weighted/","page":"-","title":"-","text":"    apply functions over windows into weighted data\r\n\r\n`rolling`, `tiling`, and `running` all provide data weighting.\r\n\r\nThe functions for weighted data follow the unweighted function signatures.\r\n- the weighting is given after the data, as the last positional arg\r\n\r\nWeighting for a data vector is given as one of the subtypes of StatsBase.AbstractWeights","category":"page"},{"location":"approach/weighted/","page":"-","title":"-","text":"To use myweights::Vector{<:Real} as weights","category":"page"},{"location":"approach/weighted/","page":"-","title":"-","text":"scale the values so they sum to 1.0 (or a few eps less than 1.0)\nmyweights1 = LinearAlgebra.normalize(myweights, 1) (ok)\nmyweights1 = safeweights(myweights1) (better)\nconvert the values to StatsBase.AnalyticWeights\nweighting = AnalyticWeights(myweights1)","category":"page"},{"location":"approach/weighted/","page":"-","title":"-","text":"","category":"page"},{"location":"approach/weighted/","page":"-","title":"-","text":"See also: safeweights,           datastreams","category":"page"},{"location":"intro/windoweddata/","page":"-","title":"-","text":"(Windowed Data)","category":"page"},{"location":"approach/atend/","page":"-","title":"-","text":"    atend -- optional keyword argument","category":"page"},{"location":"approach/atend/","page":"-","title":"-","text":"atend is a keyword argument that defaults to false.","category":"page"},{"location":"approach/atend/","page":"-","title":"-","text":"additional value[s] are placed at the start of the results.","category":"page"},{"location":"approach/atend/","page":"-","title":"-","text":"using atend = true","category":"page"},{"location":"approach/atend/","page":"-","title":"-","text":"additional value[s] are placed at the end (highest indices).","category":"page"},{"location":"approach/atend/","page":"-","title":"-","text":"By default, padding is applied at the begining of the result.","category":"page"},{"location":"approach/atend/","page":"-","title":"-","text":"the padding value is placed at the lowest indices","category":"page"},{"location":"approach/atend/","page":"-","title":"-","text":"To apply padding at the end of the result, set atend=true.","category":"page"},{"location":"approach/atend/","page":"-","title":"-","text":"the padding value is placed at the highest indices","category":"page"},{"location":"approach/atend/","page":"-","title":"-","text":"See also: padding,           rolling,           tiling,           running","category":"page"},{"location":"approach/safeweights/","page":"-","title":"-","text":"    safeweights(<:AbstractVector{T})::AbstractVector{T}","category":"page"},{"location":"approach/safeweights/","page":"-","title":"-","text":"ensures that the sum of the weights","category":"page"},{"location":"approach/safeweights/","page":"-","title":"-","text":"does not exceed 1\napproaches or is equal to 1","category":"page"},{"location":"approach/safeweights/","page":"-","title":"-","text":"one(T) >= safesum > prevfloat(one(T), k)","category":"page"},{"location":"approach/safeweights/","page":"-","title":"-","text":"safesum = sum(safeweights(weights))\nk <= ceil(1 + log10(wlength) + wlength^(5/16))\nwlength = length(weights)","category":"page"},{"location":"approach/safeweights/","page":"-","title":"-","text":"See also: weighted","category":"page"},{"location":"use/running_examples/","page":"Running examples (basic)","title":"Running examples (basic)","text":"You have a data sequence 𝐷𝑎𝑡𝑎, the Vector[1, 2, 3, 4, 5].\nThe window width 𝑆𝑝𝑎𝑛 of each subsequence is 3.\nThe function 𝐹𝑢𝑛𝑐 to be applied over subsequences of 𝐷𝑎𝑡𝑎 is sum.","category":"page"},{"location":"use/running_examples/","page":"Running examples (basic)","title":"Running examples (basic)","text":"using RollingFunctions\n\n𝐷𝑎𝑡𝑎 = [1, 2, 3, 4, 5]\n𝐹𝑢𝑛𝑐 = sum\n𝑆𝑝𝑎𝑛 = 3\n\nresult = running(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛)\njulia> result\n3-element Vector{Int64}:\n  6\n  9\n 12\n\n#=\nThe first  windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the first  𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎.\nThe second windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the second 𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎.\nThe third  windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the third  𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎.\n\nThere can be no fourth value as the third value used the fins entries in𝐷𝑎𝑡𝑎.\n=#\n\njulia> sum(𝐷𝑎𝑡𝑎[1:3]), sum(𝐷𝑎𝑡𝑎[2:4]), sum(𝐷𝑎𝑡𝑎[3:5])\n(6, 9, 12)\nIf the width of each subsequence increases to 4..\n\n𝑆𝑝𝑎𝑛 = 4\nresult = running(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛);\n\nresult\n2-element Vector{Int64}:\n 10\n 14","category":"page"},{"location":"use/running_examples/","page":"Running examples (basic)","title":"Running examples (basic)","text":"Using a width of s over data with r rows results in r - s + 1 values.","category":"page"},{"location":"use/running_examples/","page":"Running examples (basic)","title":"Running examples (basic)","text":"to obtain values, use padding or tapering","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"","category":"page"},{"location":"use/runoverdata/#This-package-makes-it-easy-to-summarize-windowed-data.","page":"Running over windowed data","title":"This package makes it easy to summarize windowed data.","text":"","category":"section"},{"location":"use/runoverdata/#A-function-is-applied-to-successive-data-subsequences.","page":"Running over windowed data","title":"A function is applied to successive data subsequences.","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"You give a summarizing function 𝐹𝑢𝑛𝑐, the data𝐷𝑎𝑡𝑎, and a window width 𝑆𝑝𝑎𝑛.  ","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"The result  𝑅 is of length  𝑅ᴺ,   𝑅ᴺ = length(𝐷𝑎𝑡𝑎) - 𝑆𝑝𝑎𝑛 + 1.","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"the result omits  𝑅ᴼ = 𝑆𝑝𝑎𝑛 - 1 indices that𝐷𝑎𝑡𝑎 uses.","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"","category":"page"},{"location":"use/runoverdata/#*ways-to-get-as-many-results-as-there-are-data-values*","page":"Running over windowed data","title":"ways to get as many results as there are data values","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"","category":"page"},{"location":"use/runoverdata/#Use-a-vector-of-padding-values-with-length-𝑅ᴼ","page":"Running over windowed data","title":"Use a vector of padding values with length  𝑅ᴼ","text":"","category":"section"},{"location":"use/runoverdata/#specify-a-padding-vector-(default-is-at-the-start)","page":"Running over windowed data","title":"specify a padding vector (default is at the start)","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"here is the way to do that\nrunning(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = [<values>])\nrunning(function, data, width; padding = [<values>])","category":"page"},{"location":"use/runoverdata/#specify-the-padding-vector-to-be-at-the-end","page":"Running over windowed data","title":"specify the padding vector to be at the end","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"here is the way to do that\nrunning(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = [<values>], atend = true)\nrunning(function, data, width; padding = [<values>], atend = true)","category":"page"},{"location":"use/runoverdata/#Use-an-empty-vector","page":"Running over windowed data","title":"Use an empty vector","text":"","category":"section"},{"location":"use/runoverdata/#this-fills-the-𝑅ᴼ-indices-by-trimming","page":"Running over windowed data","title":"this fills the  𝑅ᴼ indices by trimming","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"here is the way to do that\nrunning(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = eltype(𝐷𝑎𝑡𝑎)[])\nrunning(function, data, width; padding = eltype(𝐷𝑎𝑡𝑎)[])","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"-trimming evaluates the window function over available data","category":"page"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"trimmed window widths are less than the specified width","category":"page"},{"location":"use/runoverdata/#Use-a-vector-of𝓃-padding-values","page":"Running over windowed data","title":"Use a vector of𝓃 padding values","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"where1 <= 𝓃 <   𝑅ᴼ.","category":"page"},{"location":"use/runoverdata/#this-both-pads-and-trims-to-assign-the-initial-indices","page":"Running over windowed data","title":"this both pads and trims to assign the initial indices","text":"","category":"section"},{"location":"use/runoverdata/","page":"Running over windowed data","title":"Running over windowed data","text":"the first𝓃 indices of the result will match this vector\nthe next  𝑅ᴼ - 𝓃 indices of the result will be trimmed\nthe remaining indices get the rolled results.","category":"page"},{"location":"approach/datastreams/","page":"-","title":"-","text":"    datastreams\r\n\r\nThere are four ways to provide data\r\nfor `rolling`, `tiling`, or `running`.","category":"page"},{"location":"approach/datastreams/","page":"-","title":"-","text":"data sources [usually] have a numeric eltype","category":"page"},{"location":"approach/datastreams/","page":"-","title":"-","text":"(a) a unary function over windows into one vector","category":"page"},{"location":"approach/datastreams/","page":"-","title":"-","text":"(b) a binary function over matching windows into two vectors","category":"page"},{"location":"approach/datastreams/","page":"-","title":"-","text":"(c) a three arg function over windows into three vectors","category":"page"},{"location":"approach/datastreams/","page":"-","title":"-","text":"(d) a unary function windowed over each column of a matrix","category":"page"},{"location":"approach/datastreams/","page":"-","title":"-","text":"each column of the matrix is treated as a simple vector\nthere is no current provision for n-ary summary functions\nthe same unary function is applied over each column\nthe same windowing is applied to each column","category":"page"},{"location":"approach/datastreams/","page":"-","title":"-","text":"create a window-ready function using constitutive applicands","category":"page"},{"location":"approach/datastreams/","page":"-","title":"-","text":"fn(v1,v2,v3,v4,v5,v6) = fnab(fna(v1, v2, v3), fnb(v3, v4, v5))","category":"page"},{"location":"approach/datastreams/","page":"-","title":"-","text":"See also: rolling,           tiling,           running","category":"page"},{"location":"intro/matrix_padding/","page":"Roll over matrices (padding)","title":"Roll over matrices (padding)","text":"You may pad the result with the padding value of your choice","category":"page"},{"location":"intro/matrix_padding/","page":"Roll over matrices (padding)","title":"Roll over matrices (padding)","text":"padding is a keyword argument","category":"page"},{"location":"intro/matrix_padding/","page":"Roll over matrices (padding)","title":"Roll over matrices (padding)","text":"if you assign e.g. padding = missing, the result will be padfirst\nyou may pad using any defined value and all types except Nothing\nexample pads(missing, 0, nothing, NaN, '∅', AbstractString)","category":"page"},{"location":"intro/matrix_padding/","page":"Roll over matrices (padding)","title":"Roll over matrices (padding)","text":"using RollingFunctions","category":"page"},{"location":"intro/matrix_padding/","page":"Roll over matrices (padding)","title":"Roll over matrices (padding)","text":"𝐷𝑎𝑡𝑎₁ = [1, 2, 3, 4, 5] 𝐷𝑎𝑡𝑎₂ = [5, 4, 3, 2, 1] 𝐷𝑎𝑡𝑎₃ = [1, 2, 3, 2, 1]","category":"page"},{"location":"intro/matrix_padding/","page":"Roll over matrices (padding)","title":"Roll over matrices (padding)","text":"𝑀 = hcat(𝐷𝑎𝑡𝑎₁,𝐷𝑎𝑡𝑎₂,𝐷𝑎𝑡𝑎₃) #= 5×3 Matrix{Int64}:  1  5  1  2  4  2  3  3  3  4  2  2  5  1  1 =#","category":"page"},{"location":"intro/matrix_padding/","page":"Roll over matrices (padding)","title":"Roll over matrices (padding)","text":"𝐹𝑢𝑛𝑐 = sum 𝑆𝑝𝑎𝑛 = 3","category":"page"},{"location":"intro/matrix_padding/","page":"Roll over matrices (padding)","title":"Roll over matrices (padding)","text":"result = rolling(𝐹𝑢𝑛𝑐, 𝑀, 𝑆𝑝𝑎𝑛; padding=missing) #= 5×3 Matrix{Union{Missing,Int64}}: missing missing missing missing missing missing   6  12  6   9   9  7  12   6  6 =#","category":"page"},{"location":"intro/matrix_padding/#Give-me-the-real-values-first,-pad-to-the-end.","page":"Roll over matrices (padding)","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"intro/matrix_padding/","page":"Roll over matrices (padding)","title":"Roll over matrices (padding)","text":"result = rolling(𝐹𝑢𝑛𝑐, 𝑀, 𝑆𝑝𝑎𝑛; padding = missing, atend=true) #= 5×3 Matrix{Union{Missing,Int64}}:   6  12  6   9   9  7  12   6  6    missing    missing   missing    missing    missing   missing =#","category":"page"},{"location":"intro/matrix_padding/","page":"Roll over matrices (padding)","title":"Roll over matrices (padding)","text":"technical aside: this is not the same as reverse(rolling(𝒮,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = missing).","category":"page"},{"location":"design/approach/","page":"approach","title":"approach","text":"This package supports distinct approaches to appling a  moving window function over data sequences. The core design develops each approach in the same way. This simplifies development, mitigates unexpected corner cases, and improves reliability.","category":"page"},{"location":"design/approach/","page":"approach","title":"approach","text":"At present, there are three approachs:  running,  tiling, and  rolling.","category":"page"},{"location":"design/approach/","page":"approach","title":"approach","text":"We use two keyword arguments, both are optional: padding, and  atend.","category":"page"},{"location":"design/approach/","page":"approach","title":"approach","text":"This allows four call states for each approach","category":"page"},{"location":"design/approach/","page":"approach","title":"approach","text":"<approach>(windowed_fn, window_width, data_seq)\r\n<approach>(windowed_fn, window_width, data_seq; padding=pad)\r\n<approach>(windowed_fn, window_width, data_seq; atend=true)\r\n<approach>(windowed_fn, window_width, data_seq; padding=pad, atend=true)","category":"page"},{"location":"design/approach/","page":"approach","title":"approach","text":"For every approach, there are four data configurations:","category":"page"},{"location":"design/approach/","page":"approach","title":"approach","text":"one vector\ntwo vectors (of equal length)\nthree vectors (of equal length)\na matrix of 2 or more columns","category":"page"},{"location":"design/approach/","page":"approach","title":"approach","text":"For every approach, the data sequence may be weighted.  There are three ways to introduce weights:","category":"page"},{"location":"design/approach/","page":"approach","title":"approach","text":"for any data configuration\nas a vector where isa(vector, StatsBase.AbstractWeights)\nfor multiple data sequences or a data matrix\nas a vector where isa(vector, Vector{<:StatsBase.AbstractWeights})\nas a matrix where isa(matrix, <:Matrix{Number})","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"","category":"page"},{"location":"use/rolloverdata/#This-package-makes-it-easy-to-summarize-windowed-data.","page":"Rolling over windowed data","title":"This package makes it easy to summarize windowed data.","text":"","category":"section"},{"location":"use/rolloverdata/#A-function-is-applied-to-successive-data-subsequences.","page":"Rolling over windowed data","title":"A function is applied to successive data subsequences.","text":"","category":"section"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"You give a summarizing function 𝐹𝑢𝑛𝑐, the data𝐷𝑎𝑡𝑎, and a window width 𝑆𝑝𝑎𝑛.  ","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"The result    𝑅 is of length   𝑅ᴺ","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"𝑅ᴺ = length(𝐷𝑎𝑡𝑎) - 𝑆𝑝𝑎𝑛 + 1.\nthe result omits 𝑅ᴼ = 𝑆𝑝𝑎𝑛 - 1 indices that𝐷𝑎𝑡𝑎 uses.\nhere is the way to do that\nrolling(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛)\nrolling(function, data, width)","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"","category":"page"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"","category":"page"},{"location":"use/rolloverdata/#*ways-to-get-as-many-results-as-there-are-data-values*","page":"Rolling over windowed data","title":"ways to get as many results as there are data values","text":"","category":"section"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"","category":"page"},{"location":"use/rolloverdata/#Use-a-single,-shared-padding-value","page":"Rolling over windowed data","title":"Use a single, shared padding value","text":"","category":"section"},{"location":"use/rolloverdata/#specify-a-padding-value-(default-position-is-at-the-start)","page":"Rolling over windowed data","title":"specify a padding value (default position is at the start)","text":"","category":"section"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"here is the way to do that\nrolling(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = \\<value\\>)\nrolling(function, data, width; padding = missing)\nthis will fill the initial result values with the padding value\npads these values(result[1], .., result[pad_nindices])","category":"page"},{"location":"use/rolloverdata/#specify-padding-to-be-at-the-end-of-the-result","page":"Rolling over windowed data","title":"specify padding to be at the end of the result","text":"","category":"section"},{"location":"use/rolloverdata/","page":"Rolling over windowed data","title":"Rolling over windowed data","text":"here is the way to do that\nrolling(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = <value>, atend = true)\nrolling(function, data, width; padding = missing, atend = true)\nthis will fill the final result values with the padding value\npads these values(result[n-pad_nindices+1], .., result[n])","category":"page"},{"location":"approach/tiling/","page":"tiling","title":"tiling","text":"    tiling(tiling_fn, window_width, data_seq)\r\n\r\ntiling(tiling_fn, window_width, data_seq; padding=nopadding)\r\n    tiling(tiling_fn, window_width, data_seq; padding, atend=false) ","category":"page"},{"location":"approach/tiling/","page":"tiling","title":"tiling","text":"tiling applies a summarizing or condensing function (fn) to all elements within the current window (seen simulataneously); then advances the window ([start:finish]) by the window_width  ([start+width:finish+width]), skipping over the prior window,  to apply fn over the elements covered by the new window ...","category":"page"},{"location":"approach/tiling/","page":"tiling","title":"tiling","text":"\ntiling(fn, width, data)\ntiling(fn, width, data; padding)\ntilling(fn, width, data; atend)\ntiling(fn, width, data; padding, atend)\n","category":"page"},{"location":"approach/tiling/","page":"tiling","title":"tiling","text":"arguments","category":"page"},{"location":"approach/tiling/","page":"tiling","title":"tiling","text":"fn <: Function:   summarizes, condenses windowed data\nwidth::Integer:   window breadth, counts covered elements.\ndata_seq::Vector: the data over which the window moves.","category":"page"},{"location":"approach/tiling/","page":"tiling","title":"tiling","text":"keywords","category":"page"},{"location":"approach/tiling/","page":"tiling","title":"tiling","text":"padding::Any=nopadding: the value place as filler.\natend::Bool=false:     where to place the padding.","category":"page"},{"location":"approach/tiling/","page":"tiling","title":"tiling","text":"See also: padding,            atend,           weighted,           datastreams","category":"page"},{"location":"approach/running/","page":"running","title":"running","text":"    running(running_fn, window_width, data_seq)\r\n\r\nrunning(running_fn, window_width, data_seq; atend=false)","category":"page"},{"location":"approach/running/","page":"running","title":"running","text":"running applies a summarizing or condensing function (fn) to all elements within the current window (seen simulataneously); then advances the window ([start:finish]) by one index ([start+1:finish+1]) to apply fn over the elements covered by the new window ...","category":"page"},{"location":"approach/running/","page":"running","title":"running","text":"running differs from rolling. When rolling() one may pad values that otherwise would be dropped to obtain a result of length that matches expectation or convienience.","category":"page"},{"location":"approach/running/","page":"running","title":"running","text":"Running() provides replacements for those dropped values by tapering the width of the window as it moves from the start [as it moves to the end] of the data sequence (see atend).","category":"page"},{"location":"approach/running/","page":"running","title":"running","text":"\nrunning(fn, width, data)\nrunning(fn, width, data; atend)\n","category":"page"},{"location":"approach/running/","page":"running","title":"running","text":"arguments","category":"page"},{"location":"approach/running/","page":"running","title":"running","text":"fn <: Function:     summarizes, condenses windowed data\nwidth::Integer:     window breadth, counts covered elements.\ndata_seq::Vector:   the data over which the window moves.","category":"page"},{"location":"approach/running/","page":"running","title":"running","text":"keywords","category":"page"},{"location":"approach/running/","page":"running","title":"running","text":"atend::Bool=false:  where to place the tapering.","category":"page"},{"location":"approach/running/","page":"running","title":"running","text":"See also: atend,           weighted,           datastreams","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"There are two distinct sorts of windows that are taken over data: rolling and tiled.  ","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"Rolling windows advance step-by-step over the data\neach step advances the indices widthned by 1\nTiled windows advance in larger strides over the data\neach stride advances the indices widthned by a fixed multistep","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"With tiled windows, the tiling (the width that describes the indices covered by each tile) and the multistep increment are the same in most uses. An example of this is summarizing a week of daily data with a tiling of 7 and then moving to the following week with a multistep of 7.","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"To use a multistep increment that is less than the tiling is permitted. As an example, summarize two weeks of daily data with a tiling of 14 and skip over one week with a multistep of 7 to allow you to analyze two week intervals one week at a time.","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"To use a multistep increment that exceeds the tiling is permitted. As an example, summarize a week of daily data with a tiling of 7 and skip over two weeks with a multistep of 14 to allow you to analyze odd weeks and use that analysis along with the even weeks to constrain a model.","category":"page"},{"location":"thanks/","page":"Thanks","title":"Thanks","text":"There have been many who contributed.","category":"page"},{"location":"thanks/","page":"Thanks","title":"Thanks","text":"These people have done more, some without trying.","category":"page"},{"location":"thanks/","page":"Thanks","title":"Thanks","text":"thanks \nEliot Saba @staticfloat\nBogumił Kamiński @bkamins\nMiguel Raz Guzmán Macedo @miguelraz\nTyler Beason @tbeason\nKevin Patel @kevindirect","category":"page"},{"location":"intro/multicolumn_padding/","page":"Roll over multicolumn data (padding)","title":"Roll over multicolumn data (padding)","text":"You may pad the result with the value of your choice","category":"page"},{"location":"intro/multicolumn_padding/#padding-is-a-keyword-argument","page":"Roll over multicolumn data (padding)","title":"padding is a keyword argument","text":"","category":"section"},{"location":"intro/multicolumn_padding/","page":"Roll over multicolumn data (padding)","title":"Roll over multicolumn data (padding)","text":"if you assign e.g. padding = missing, the result will be padfirst\nyou may pad using any defined value and all types except Nothing\nexample pads(missing, 0, nothing, NaN, '∅', AbstractString)","category":"page"},{"location":"intro/multicolumn_padding/","page":"Roll over multicolumn data (padding)","title":"Roll over multicolumn data (padding)","text":"using RollingFunctions\n\n𝐷𝑎𝑡𝑎₁ = [1, 2, 3, 4, 5]\n𝐷𝑎𝑡𝑎₂ = [5, 4, 3, 2, 1]\n\n𝐹𝑢𝑛𝑐 = cov\n𝑆𝑝𝑎𝑛 = 3\n\nresult = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎₁, 𝐷𝑎𝑡𝑎₂, 𝑆𝑝𝑎𝑛; padding = zero(eltype(𝑀)))\n\n#=\njulia> result\n5 element Vector {Float64}:\n  0.0\n  0.0\n -1.0\n -1.0\n -1.0\n=#","category":"page"},{"location":"intro/multicolumn_padding/#Give-me-the-real-values-first,-pad-to-the-end.","page":"Roll over multicolumn data (padding)","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"intro/multicolumn_padding/","page":"Roll over multicolumn data (padding)","title":"Roll over multicolumn data (padding)","text":"result = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎₁, 𝐷𝑎𝑡𝑎₂, 𝑆𝑝𝑎𝑛; padding = missing, atend=true)\n\n#=\n5 element Vector {Float64}:\n -1.0\n -1.0\n -1.0\n  missing\n  missing\n=#","category":"page"},{"location":"intro/multicolumn_padding/","page":"Roll over multicolumn data (padding)","title":"Roll over multicolumn data (padding)","text":"technical aside: this is not the same as reverse(rolling(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎₁, 𝐷𝑎𝑡𝑎₂, 𝑆𝑝𝑎𝑛; padding = missing).","category":"page"},{"location":"intro/padding/","page":"Roll over vectors (padding)","title":"Roll over vectors (padding)","text":"You may pad the result with the value of your choice","category":"page"},{"location":"intro/padding/#padding-is-a-keyword-argument","page":"Roll over vectors (padding)","title":"padding is a keyword argument","text":"","category":"section"},{"location":"intro/padding/","page":"Roll over vectors (padding)","title":"Roll over vectors (padding)","text":"if you assign e.g. padding = missing, the result will be padfirst\nyou may pad using any defined value and all types except Nothing\nexample pads(missing, 0, nothing, NaN, '∅', AbstractString)","category":"page"},{"location":"intro/padding/","page":"Roll over vectors (padding)","title":"Roll over vectors (padding)","text":"using RollingFunctions\n\n𝐷𝑎𝑡𝑎 = [1, 2, 3, 4, 5]\n𝐹𝑢𝑛𝑐 = sum\n𝑆𝑝𝑎𝑛 = 3\n\nresult = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = missing);\n#=\njulia> result\n5-element Vector{Union{Missing, Int64}}:\n   missing\n   missing\n  6\n  9\n 12\n=#\n \nresult = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = zero(eltype(𝐷𝑎𝑡𝑎));\n#=\njulia> result\n5-element Vector{Int64}:\n  0\n  0\n  6\n  9\n 12\n=#","category":"page"},{"location":"intro/padding/#Give-me-the-real-values-first,-pad-to-the-end.","page":"Roll over vectors (padding)","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"intro/padding/","page":"Roll over vectors (padding)","title":"Roll over vectors (padding)","text":"result = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = missing, atend=true);\n#=\njulia> result\n5-element Vector{Union{Missing,Int64}}:\n  6\n  9\n 12\n  missing\n  missing\n=#","category":"page"},{"location":"intro/padding/","page":"Roll over vectors (padding)","title":"Roll over vectors (padding)","text":"technical aside: this is not the same as reverse(rolling(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = zero(eltype(𝐷𝑎𝑡𝑎)).","category":"page"},{"location":"design/dispatch/#**Positional-Signatures**","page":"dispatch","title":"Positional Signatures","text":"","category":"section"},{"location":"design/dispatch/#*each-approach-subsumes-64-signatures*","page":"dispatch","title":"each approach subsumes 64 signatures","text":"","category":"section"},{"location":"design/dispatch/","page":"dispatch","title":"dispatch","text":"With 2 keyword args, there are 4 positional signatures (one for each state shown in approach).\nWith the 4 data configurations that becomes 4x4 = 16 signatures.\nWith the 3 ways to weight + unweighted this gives 16x4 = 64 signatures.","category":"page"},{"location":"design/dispatch/#*enfolding-signatures*","page":"dispatch","title":"enfolding signatures","text":"","category":"section"},{"location":"api/running/#these-are-the-three-foundational-forms-that-run","page":"running","title":"these are the three foundational forms that run","text":"","category":"section"},{"location":"api/running/","page":"running","title":"running","text":"running(window_fn, datavec, width)\n\nrunning(window_fn, datavec, width; padding)\n\nrunning(window_fn, datavec, width; padding, atend)","category":"page"},{"location":"api/running/#enhanced-forms-allow-2,-3,-or-4-distinct-data-vectors","page":"running","title":"enhanced forms allow 2, 3, or 4 distinct data vectors","text":"","category":"section"},{"location":"api/running/","page":"running","title":"running","text":"they support summarizing functions that take 2, 3, or 4 args","category":"page"},{"location":"api/running/","page":"running","title":"running","text":"running(window_fn, datavec1, datavec2, width)\n\nrunning(window_fn, datavec1, datavec2, datavec3, width; padding)\n\nrunning(window_fn, datavec1, datavec2, datavec3, datavec4, width; padding, atend)","category":"page"},{"location":"api/running/#given-a-matrix,-the-function-is-applied-to-each-column","page":"running","title":"given a matrix, the function is applied to each column","text":"","category":"section"},{"location":"api/running/","page":"running","title":"running","text":"a corresponding matrix is returned","category":"page"},{"location":"api/running/","page":"running","title":"running","text":"running(window_fn, datamat, width)\n\nrunning(window_fn, datamat, width; padding)\n\nrunning(window_fn, datamat, width; padding, atend)","category":"page"},{"location":"api/tiling/#for-brevity","page":"tiling","title":"for brevity","text":"","category":"section"},{"location":"api/tiling/","page":"tiling","title":"tiling","text":"fn1(x)        is a function of 1 argument,  returns a scalar\nfn2(x, y)     is a function of 2 arguments, returns a scalar\nfn3(x, y, z)  is a function of 3 arguments, returns a scalar","category":"page"},{"location":"api/tiling/","page":"tiling","title":"tiling","text":"const AV  = AbstractVector\r\nconst PVD = nopadding # padding[value]_default\r\nconst PLD = false # atend_default","category":"page"},{"location":"api/tiling/#these-are-the-three-foundational-forms-that-roll","page":"tiling","title":"these are the three foundational forms that roll","text":"","category":"section"},{"location":"api/tiling/","page":"tiling","title":"tiling","text":"tiling(fn1, width, data1::V) where {V<:AV}\r\n\r\ntiling(fn1, width, data1::V;\r\n        padding=PVD) where {V<:AV}\r\n\r\ntiling(fn1, width, data1::V;\r\n        padding=PVD, atend=PLD) where {V<:AV}","category":"page"},{"location":"api/tiling/#enhanced-forms-allow-two-or-three-distinct-data-vectors","page":"tiling","title":"enhanced forms allow two or three distinct data vectors","text":"","category":"section"},{"location":"api/tiling/","page":"tiling","title":"tiling","text":"they support summarizing functions that take 2 or 3  args","category":"page"},{"location":"api/tiling/","page":"tiling","title":"tiling","text":"tiling(fn2, width, data1::V, data2::V) where {V<:AV}\r\n\r\ntiling(fn2, width, data1::V, data2::V;\r\n        padding=PVD) where {V<:AV}\r\n\r\ntiling(fn2, width, data1::V, data2::V;\r\n        padding=PVD, atend=PLD) where {V<:AV}","category":"page"},{"location":"api/tiling/","page":"tiling","title":"tiling","text":"tiling(fn3, width, data1::V, data2::V, data3::V) where {V<:AV}\r\n\r\ntiling(fn3, width, data1::V, data2::V, data3::V;\r\n        padding=PVD) where {V<:AV}\r\n\r\ntiling(fn3, width, data1::V, data2::V, data3::V;\r\n        padding=PVD, atend=PLD) where {V<:AV}","category":"page"},{"location":"api/tiling/#given-a-matrix,-the-function-is-applied-to-each-column","page":"tiling","title":"given a matrix, the function is applied to each column","text":"","category":"section"},{"location":"api/tiling/","page":"tiling","title":"tiling","text":"a corresponding matrix is returned","category":"page"},{"location":"api/tiling/","page":"tiling","title":"tiling","text":"tiling(fn1, datamat, width)\r\n\r\ntiling(fn1, datamat, width; padding)\r\n\r\ntiling(fn1, datamat, width; padding, atend)","category":"page"},{"location":"#Apply-functions-over-windows-that-advance-through-data.","page":"Home","title":"Apply functions over windows that advance through data.","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"\nRollingFunctions.jl © 2017-2023 by Jeffrey Sarnoff\n","category":"page"},{"location":"#in-three-different-ways","page":"Home","title":"in three different ways","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"rolling\ntiling\nrunning","category":"page"},{"location":"#optionally-specifying","page":"Home","title":"optionally specifying","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"weights\npadding\npad placement","category":"page"},{"location":"#with-these-data-sequences","page":"Home","title":"with these data sequences","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"datastreams","category":"page"},{"location":"#some-approaches","page":"Home","title":"some approaches","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"analyze synthesize\nsummarize aggregate\ncondense combine\ntest sample\n ","category":"page"},{"location":"intro/matrix_rolling/","page":"Roll over matricies (basics)","title":"Roll over matricies (basics)","text":"#=\n\nYou have n data vectors of equal length (rowcount 𝓇)\n𝐷𝑎𝑡𝑎₁ .. 𝐷𝑎𝑡𝑎ᵢ .. 𝐷𝑎𝑡𝑎ₙ  collected as an 𝓇 x 𝓃 matrix 𝑀\nyou want to apply the same function (sum) \nto colum-wise triple row subsequences, successively\n\n=#\n\nusing RollingFunctions\n\n𝐷𝑎𝑡𝑎₁ = [1, 2, 3, 4, 5]\n𝐷𝑎𝑡𝑎₂ = [5, 4, 3, 2, 1]\n𝐷𝑎𝑡𝑎₃ = [1, 2, 3, 2, 1]\n\n𝑀 = hcat(𝐷𝑎𝑡𝑎₁, 𝐷𝑎𝑡𝑎₂, 𝐷𝑎𝑡𝑎₃);\n\n#=\njulia> 𝑀\n5×3 Matrix{Int64}:\n 1  5  1\n 2  4  2\n 3  3  3\n 4  2  2\n 5  1  1\n=#\n\n𝐹𝑢𝑛𝑐 = sum\n𝑆𝑝𝑎𝑛 = 3\n\nresult = rolling(𝐹𝑢𝑛𝑐, 𝑀, 𝑆𝑝𝑎𝑛)\n\n#=\njulia> result\n3×3 Matrix{Int64}:\n  6  12  6\n  9   9  7\n 12   6  6\n=#\n","category":"page"},{"location":"intro/multicolumn_rolling/","page":"Roll over multicolumn data (basics)","title":"Roll over multicolumn data (basics)","text":"#=\n\nYou have n data vectors of equal length (rowcount 𝓇)\n𝐷𝑎𝑡𝑎₁ .. 𝐷𝑎𝑡𝑎ᵢ .. 𝐷𝑎𝑡𝑎ₙ\nyou apply a function (StatsBase.cor) of n==2 arguments\nto subsequences of width 3 (over successive triple rows)\n\n=#\n\nusing RollingFunctions\n\n𝐷𝑎𝑡𝑎₁ = [1, 2, 3, 4, 5]\n𝐷𝑎𝑡𝑎₂ = [5, 4, 3, 2, 1]\n\n𝐹𝑢𝑛𝑐 = cor\n𝑆𝑝𝑎𝑛 = 3\n\nresult = rolling(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎₁,𝐷𝑎𝑡𝑎₂, 𝑆𝑝𝑎𝑛)\n#=\n3-element Vector{Float64}:\n  -1.0\n  -1.0\n  -1.0\n=#\n","category":"page"}]
}
